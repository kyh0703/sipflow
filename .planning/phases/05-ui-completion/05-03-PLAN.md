---
phase: 05-ui-completion
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/engine/integration_test.go
autonomous: true

must_haves:
  truths:
    - "go test ./internal/... 실행 시 모든 테스트(기존 + 신규) 통과"
    - "E2E 테스트가 2자 통화 시나리오(발신->응답->종료) 검증을 시뮬레이션으로 수행"
    - "이벤트 스트림이 노드 상태 변경과 액션 로그를 정상 발행"
    - "시나리오 완료 후 cleanup이 정상 수행됨"
  artifacts:
    - path: "internal/engine/integration_test.go"
      provides: "E2E 2-party call 테스트 + 이벤트 스트림 검증 테스트"
      contains: "TestIntegration_TwoPartyCallSimulation"
  key_links:
    - from: "internal/engine/integration_test.go"
      to: "internal/engine/engine.go"
      via: "Engine.StartScenario() 호출로 전체 실행 파이프라인 검증"
      pattern: "StartScenario"
    - from: "internal/engine/integration_test.go"
      to: "internal/engine/executor.go"
      via: "EventEmitter를 통한 이벤트 스트림 검증"
      pattern: "GetEventsByName"
---

<objective>
Go 백엔드 E2E 통합 테스트를 확장하여 2자 통화 시나리오의 전체 실행 흐름을 검증한다.

Purpose: MVP 안정성 확보. 시나리오 실행 엔진의 핵심 경로(시작 → 노드 실행 → 이벤트 발행 → 완료 → 정리)를 자동화된 테스트로 보장한다.
Output: 기존 integration_test.go에 추가된 E2E 테스트, 전체 go test 통과.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ui-completion/CONTEXT.md
@.planning/phases/05-ui-completion/05-RESEARCH.md

@internal/engine/integration_test.go
@internal/engine/engine.go
@internal/engine/executor.go
@internal/engine/graph.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: E2E 2자 통화 시뮬레이션 테스트 + 이벤트 스트림 검증</name>
  <files>
    internal/engine/integration_test.go
  </files>
  <action>
    1. `integration_test.go`에 `TestIntegration_TwoPartyCallSimulation` 추가:
       - 기존 `TestIntegration_TwoPartyCall`은 localhost 포트 충돌로 t.Skip됨 (라인 119)
       - 새 테스트는 시뮬레이션 가능한 구조로 작성:
         - 단일 인스턴스 시나리오가 아닌, 실행 엔진의 전체 파이프라인을 검증하는 방식
         - Instance A: SIPInstance → MakeCall 노드 (diago localhost 제약으로 실제 SIP 불가하므로, 타임아웃 기반 시나리오 구성)
         - 대안 접근: 하나의 인스턴스로 Command 체인 (MakeCall → Release) 또는 Event 체인 (TIMEOUT → TIMEOUT) 테스트
         - 핵심: 여러 노드가 순차적으로 completed 상태에 도달하고, 이벤트 스트림이 올바르게 발행되며, cleanup이 완료되는지 검증

       구체적 시나리오 A: **Command 체인 테스트**
       ```
       Instance A (dn: "100") → TIMEOUT(500ms) → TIMEOUT(500ms)
       ```
       - TIMEOUT 이벤트는 딜레이로 구현됨 (03-03 결정사항)
       - 두 개의 TIMEOUT 노드가 순차 실행되어 모두 completed 도달 검증
       - 시나리오 최종 상태 "completed" 검증

       구체적 시나리오 B: **이벤트 스트림 포괄 테스트**
       - 기존 SingleInstance/EventTimeout 테스트를 확장하는 형태
       - 시나리오 실행 중 발행되는 전체 이벤트 종류 검증:
         - `scenario:started` 이벤트 1회
         - `node:state` 이벤트 (각 노드별 pending → running → completed/failed)
         - `action:log` 이벤트 (각 노드 실행 시)
         - `scenario:completed` 또는 `scenario:failed` 이벤트 1회

    2. 테이블 드리븐 패턴으로 추가 시나리오 구성:
       - 기존 테스트들(`TestIntegration_SingleInstance`, `TestIntegration_EventTimeout` 등)의 패턴을 유지
       - 새 테스트는 이벤트 검증에 초점:
         ```go
         func TestIntegration_TwoPartyCallSimulation(t *testing.T) {
             // 시나리오: 2개 인스턴스, 각각 TIMEOUT 이벤트 실행
             // Instance A: TIMEOUT(500ms) - 성공 경로
             // Instance B: TIMEOUT(500ms) - 성공 경로
             // 두 인스턴스가 병렬 실행되어 모두 completed 도달
             // 전체 시나리오 completed 검증
         }
         ```

    3. `TestIntegration_EventStreamVerification` 추가:
       - 시나리오 실행 중 이벤트 스트림의 정확성을 세부 검증
       - 검증 항목:
         - scenario:started 이벤트에 scenarioId 포함
         - node:state 이벤트에 nodeId, oldState, newState 포함
         - action:log 이벤트에 nodeId, message 포함
         - scenario:completed에 scenarioId 포함
       - 이벤트 순서 검증: started → node:state(running) → action:log → node:state(completed) → completed

    4. `TestIntegration_CleanupVerification` 추가:
       - 시나리오 완료 후 cleanup 검증
       - `eng.IsRunning()` == false 확인
       - 재시작 가능 여부 확인 (완료 후 같은 시나리오 다시 시작)

    주의: diago localhost 포트 충돌로 실제 2자 SIP 통화 테스트는 불가 (기존 TestIntegration_TwoPartyCall이 skip됨). 시뮬레이션 모드(TIMEOUT 이벤트 기반)로 엔진 파이프라인 검증에 집중.
    주의: 기존 테스트의 포트 번호 할당 패턴 유지 (15060, 16060, 17060...). 새 테스트는 20060, 21060 등 사용.
    주의: `time.Sleep` 대신 `waitForEvent`/`waitForNodeState` 헬퍼 함수 활용하여 플래키 테스트 방지.
  </action>
  <verify>
    `go test ./internal/engine/ -v -run "TestIntegration_TwoPartyCallSimulation|TestIntegration_EventStreamVerification|TestIntegration_CleanupVerification"` 실행 시 모든 신규 테스트 통과.

    `go test ./internal/...` 실행 시 기존 테스트 포함 전체 통과 (TestIntegration_TwoPartyCall은 Skip 유지).
  </verify>
  <done>
    E2E 통합 테스트가 2개 인스턴스 병렬 실행, 이벤트 스트림 정확성, cleanup 완료를 검증. `go test ./internal/...` 전체 통과.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wails 빌드 검증</name>
  <files></files>
  <action>
    1. `wails build -clean` 실행하여 단일 바이너리 생성:
       - 빌드 성공 여부 확인
       - 생성된 바이너리 파일 존재 확인: `build/bin/` 디렉토리
       - 빌드 에러 발생 시 에러 메시지 기록

    2. 알려진 이슈 처리:
       - libwebkit 시스템 의존성 누락 시: 에러 메시지 기록하고 계속 진행
       - `wails build`가 환경 의존성(GTK, webkit2gtk 등)으로 실패하면:
         - 에러 내용 SUMMARY에 기록
         - `npm run build` (프론트엔드 빌드만) 단독 실행하여 프론트엔드 빌드 성공 확인
         - `go build ./...` (Go 빌드만) 단독 실행하여 Go 컴파일 성공 확인
       - 두 개별 빌드가 성공하면 Wails 통합 빌드는 시스템 의존성 해결 후 성공 가능으로 판단

    3. 빌드 결과 기록:
       - 바이너리 크기
       - 빌드 시간
       - 경고/에러 메시지
       - 시스템 의존성 이슈 여부

    주의: `wails build` 는 시스템에 GTK 및 webkit2gtk 개발 라이브러리가 필요. STATE.md에 "libwebkit 시스템 의존성 누락" 현재 이슈로 기록됨.
    주의: 빌드 실패가 Phase 5 전체 실패를 의미하지 않음. 개별 빌드(Go + 프론트엔드) 성공으로 대체 검증 가능.
  </action>
  <verify>
    - `wails build -clean` 또는 개별 빌드 (`go build ./...` + `npm run build`) 성공
    - 바이너리 존재: `ls -la build/bin/` 또는 개별 빌드 산출물 확인
    - Go 테스트 전체 통과: `go test ./internal/...`
  </verify>
  <done>
    Wails 빌드가 성공하여 단일 바이너리 생성됨, 또는 시스템 의존성 이슈로 개별 빌드(Go/Frontend)가 각각 성공함이 확인됨. 모든 Go 테스트 통과.
  </done>
</task>

</tasks>

<verification>
1. `go test ./internal/... -v` 실행 — 모든 테스트 통과 (skip 제외)
2. 신규 E2E 테스트가 시나리오 실행 파이프라인 전체 경로 검증
3. 이벤트 스트림 검증 테스트가 이벤트 종류/순서/데이터 확인
4. cleanup 테스트가 재시작 가능성 확인
5. `wails build -clean` 또는 개별 빌드 성공
</verification>

<success_criteria>
- `go test ./internal/...` 전체 통과 (기존 + 신규 테스트)
- 신규 테스트: 2-party 시뮬레이션, 이벤트 스트림 검증, cleanup 검증
- Wails 빌드 성공 또는 개별 빌드 성공 (시스템 의존성 문서화)
</success_criteria>

<output>
완료 후, `.planning/phases/05-ui-completion/05-03-SUMMARY.md` 생성
</output>
