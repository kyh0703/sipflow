---
phase: 05-ui-completion
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/src/features/scenario-builder/store/scenario-store.ts
  - frontend/src/features/scenario-builder/components/scenario-builder.tsx
  - frontend/src/features/scenario-builder/components/canvas.tsx
autonomous: true

must_haves:
  truths:
    - "노드/엣지/속성 변경 후 AUTOSAVE_DEBOUNCE_MS(2000, 사용자 결정 1-2초 범위 내) 이내에 SQLite에 자동 저장된다"
    - "드래그 중에는 저장되지 않고 드래그 완료 후에만 저장된다"
    - "헤더에 저장 상태 인디케이터가 표시된다 (Saved/Modified/Saving...)"
    - "Ctrl+S 수동 저장이 여전히 작동하며 debounce를 즉시 무시한다"
    - "시나리오 미선택 상태에서는 자동 저장이 트리거되지 않는다"
  artifacts:
    - path: "frontend/src/features/scenario-builder/store/scenario-store.ts"
      provides: "자동 저장 subscribe + debounce 로직, saveStatus 상태"
      contains: "subscribe"
    - path: "frontend/src/features/scenario-builder/components/scenario-builder.tsx"
      provides: "저장 상태 인디케이터 UI"
      contains: "saveStatus"
  key_links:
    - from: "frontend/src/features/scenario-builder/store/scenario-store.ts"
      to: "SaveScenario Wails binding"
      via: "Zustand subscribe → debounce(2000ms) → SaveScenario 호출"
      pattern: "subscribe.*isDirty"
    - from: "frontend/src/features/scenario-builder/components/scenario-builder.tsx"
      to: "frontend/src/features/scenario-builder/store/scenario-store.ts"
      via: "saveStatus 상태 구독으로 인디케이터 렌더링"
      pattern: "saveStatus"
    - from: "frontend/src/features/scenario-builder/components/canvas.tsx"
      to: "frontend/src/features/scenario-builder/store/scenario-store.ts"
      via: "onNodeDragStop에서 isDirty 설정"
      pattern: "onNodeDragStop"
---

<objective>
Zustand subscribe + debounce 기반 자동 저장을 구현하여 사용자의 변경사항이 2초 이내에 자동으로 SQLite에 저장되도록 한다.

Purpose: 데이터 손실 방지 및 UX 향상. 사용자가 명시적으로 저장하지 않아도 작업이 자동 보존된다.
Output: 자동 저장 로직, 드래그 중 저장 방지, 헤더 저장 상태 인디케이터, 기존 수동 저장과의 공존.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ui-completion/CONTEXT.md
@.planning/phases/05-ui-completion/05-RESEARCH.md
@.planning/phases/05-ui-completion/05-01-SUMMARY.md

@frontend/src/features/scenario-builder/store/scenario-store.ts
@frontend/src/features/scenario-builder/components/scenario-builder.tsx
@frontend/src/features/scenario-builder/components/canvas.tsx
@frontend/src/features/scenario-builder/hooks/use-scenario-api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: 자동 저장 subscribe 로직 + 드래그 방지 + saveStatus 상태</name>
  <files>
    frontend/src/features/scenario-builder/store/scenario-store.ts
    frontend/src/features/scenario-builder/components/canvas.tsx
  </files>
  <action>
    1. `scenario-store.ts`에 자동 저장 인프라 추가:

       a. **saveStatus 상태 추가:**
          - `ScenarioState` 인터페이스에 `saveStatus: 'saved' | 'modified' | 'saving'` 추가
          - `setSaveStatus` 액션 추가
          - 초기값: `'saved'`
          - `isDirty`가 `true`로 설정될 때 `saveStatus`도 `'modified'`로 설정

       b. **인라인 debounce 유틸리티 구현** (외부 의존성 불필요):
          ```typescript
          function debounce<T extends (...args: any[]) => any>(
            fn: T,
            delay: number
          ): { (...args: Parameters<T>): void; cancel: () => void } {
            let timeoutId: ReturnType<typeof setTimeout> | null = null
            const debounced = (...args: Parameters<T>) => {
              if (timeoutId) clearTimeout(timeoutId)
              timeoutId = setTimeout(() => fn(...args), delay)
            }
            debounced.cancel = () => {
              if (timeoutId) clearTimeout(timeoutId)
              timeoutId = null
            }
            return debounced
          }
          ```

       c. **store 외부에서 subscribe 로직 구현:**
          - `SaveScenario`를 Wails 바인딩에서 직접 import (hooks가 아닌 직접 import: `import { SaveScenario } from '../../../../wailsjs/go/binding/ScenarioBinding'`)
          - `useScenarioStore.subscribe()` 로 `isDirty` 변경 감지
          - `isDirty`가 `true`가 되면 `debouncedSave()` 호출
          - `debouncedSave` 내부:
            1. `currentScenarioId` 확인 (없으면 리턴)
            2. `isDirty` 재확인 (없으면 리턴)
            3. `setSaveStatus('saving')` 설정
            4. `SaveScenario(currentScenarioId, toFlowJSON())` 호출
            5. 성공 시: `setDirty(false)`, `setSaveStatus('saved')`, `console.log('[Autosave] Saved')`
            6. 실패 시: `setSaveStatus('modified')`, `console.error('[Autosave] Failed')`

       d. **수동 저장(Ctrl+S)에서 debounce 취소:**
          - `debouncedSave`를 모듈 스코프에서 export하여 수동 저장 시 `debouncedSave.cancel()` 호출 가능하게 함
          - 또는 store에 `saveNow` 액션 추가: debounce 취소 후 즉시 저장 수행

    2. `canvas.tsx`에서 드래그 중 저장 방지:
       - 현재 `onNodesChange`에서 `isDirty: true` 설정 중 (scenario-store.ts 라인 52-57)
       - 문제: 드래그 중 `onNodesChange`가 매 프레임 호출되어 `isDirty`가 반복 설정됨
       - 해결: `onNodeDragStop` 핸들러를 ReactFlow에 추가
       - `onNodesChange`에서 position 변경 시에는 `isDirty`를 설정하지 않도록 변경:
         - scenario-store.ts의 `onNodesChange` 수정: `changes` 중 `type === 'position'`인 것만 있으면 `isDirty` 설정 안 함
         - 또는 더 간단하게: `isDragging` 플래그를 store에 추가하여, 드래그 중에는 autosave subscribe가 무시하도록 함
       - canvas.tsx에 `onNodeDragStop` prop 추가:
         ```tsx
         const onNodeDragStop = () => {
           setDirty(true);
         };
         ```

    주의: debounce 함수를 렌더링 외부(모듈 스코프)에서 한 번만 생성. React 렌더 사이클 안에서 재생성하면 debounce가 동작하지 않음.
    주의: `subscribe`는 `useScenarioStore` 정의 파일 하단에서 호출 (모듈 로드 시 1회 실행).
    주의: 시나리오 전환 시 `isDirty`가 `false`로 설정되므로 이전 시나리오 저장이 남아있는 경우 `debouncedSave.cancel()` 호출 필요. `setCurrentScenario` 액션에서 cancel 추가.
  </action>
  <verify>
    - 노드 추가 후 2초 대기 → 콘솔에 '[Autosave] Saved' 메시지 확인
    - 노드 드래그 중 → 콘솔에 autosave 메시지 없음
    - 노드 드래그 완료 후 2초 → '[Autosave] Saved' 메시지 확인
    - 속성 패널에서 값 변경 후 2초 → autosave 동작
    - 시나리오 미선택 상태에서 → autosave 미동작
    - Ctrl+S → 즉시 저장, debounce 대기 중이던 것 취소
    - `grep -r "subscribe" frontend/src/features/scenario-builder/store/scenario-store.ts` 결과 존재
  </verify>
  <done>
    Zustand subscribe 기반 자동 저장이 isDirty 변경 감지 → 2초 debounce → SaveScenario 호출로 동작. 드래그 중 저장 방지. 수동 저장이 debounce를 즉시 취소하고 저장 실행.
  </done>
</task>

<task type="auto">
  <name>Task 2: 헤더 저장 상태 인디케이터 UI</name>
  <files>
    frontend/src/features/scenario-builder/components/scenario-builder.tsx
  </files>
  <action>
    1. `scenario-builder.tsx` 헤더 좌측의 기존 isDirty 인디케이터를 saveStatus 기반으로 교체:
       - 기존 코드 (라인 53-57):
         ```tsx
         {isDirty && (
           <span className="text-xs text-muted-foreground" title="Unsaved changes">
             ● Modified
           </span>
         )}
         ```
       - 새 코드: `saveStatus`를 store에서 구독하여 3가지 상태 표시:
         - `'saved'`: 녹색 또는 회색으로 "Saved" 텍스트 (체크 아이콘 선택적)
         - `'modified'`: 노란색/주황색 dot + "Modified" 텍스트
         - `'saving'`: "Saving..." 텍스트 (spinner 선택적으로 Loader2 아이콘)
       - 아이콘은 lucide-react에서 `Check`, `Circle`, `Loader2` 등 활용
       - `saveStatus === 'saved'`일 때 일정 시간(3초) 후 표시 숨기기는 구현하지 않음 (항상 표시하여 상태 명확)

    2. `handleSave` 함수에서 수동 저장 시 saveStatus 연동:
       - 저장 시작: `setSaveStatus('saving')`
       - 저장 성공: `setSaveStatus('saved')`, `setDirty(false)`
       - 저장 실패: `setSaveStatus('modified')`
       - Task 1에서 추가한 `debouncedSave.cancel()` 호출하여 pending autosave 취소

    주의: saveStatus를 isDirty와 별도로 관리. isDirty는 변경 추적, saveStatus는 저장 진행/완료 상태.
    주의: handleSave의 기존 alert() 에러 → Sonner toast로 교체 (Phase 04에서 Sonner 전면 도입됨).
  </action>
  <verify>
    - 헤더에서 시나리오 이름 옆에 상태 표시 확인
    - 노드 추가 → "Modified" 표시 → 2초 후 "Saving..." → "Saved" 순서 확인
    - Ctrl+S → 즉시 "Saving..." → "Saved" 확인
    - 저장 실패 시 → "Modified" 유지 확인 (네트워크 차단 테스트는 불필요, 콘솔 에러 확인)
    - `wails dev` 실행 후 전체 흐름 시각적 확인
  </verify>
  <done>
    헤더에 3가지 저장 상태(Saved/Modified/Saving...) 인디케이터가 표시되며, 자동 저장과 수동 저장 모두에서 실시간 상태 반영. handleSave에서 alert() 대신 Sonner toast 사용.
  </done>
</task>

</tasks>

<verification>
1. 노드 추가/삭제/속성 변경 후 2초 이내 자동 저장 확인
2. 노드 드래그 중 저장 미발생, 드래그 완료 후에만 저장
3. 헤더 인디케이터가 Modified → Saving... → Saved 순서로 전환
4. Ctrl+S 수동 저장이 즉시 동작하며 debounce 취소
5. 시나리오 전환 시 이전 시나리오 pending save 취소
6. 시나리오 미선택 상태에서 자동 저장 미동작
7. 앱 재시작 후 마지막 저장 데이터 유지 확인
</verification>

<success_criteria>
- Zustand subscribe로 isDirty 변경 감지, 2초 debounce 후 SaveScenario 자동 호출
- 드래그 중 isDirty 미설정, onNodeDragStop 후에만 설정
- 헤더에 saveStatus 인디케이터 (Saved/Modified/Saving...) 표시
- 수동 저장(Ctrl+S/Save 버튼)이 debounce 취소 후 즉시 저장
- 기존 시나리오 전환 시 미저장 경고 유지 (안전장치)
</success_criteria>

<output>
완료 후, `.planning/phases/05-ui-completion/05-02-SUMMARY.md` 생성
</output>
