---
phase: 08-dtmf-send-receive
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/engine/graph.go
  - internal/engine/executor.go
autonomous: true

must_haves:
  truths:
    - "SendDTMF Command 노드 실행 시 diago AudioWriterDTMF를 통해 digits 문자열의 각 digit가 RFC 2833 RTP로 전송된다"
    - "DTMFReceived Event 노드 실행 시 diago AudioReaderDTMF를 통해 DTMF digit을 수신하고, expectedDigit 필터링이 작동한다"
    - "유효하지 않은 DTMF 문자(0-9, *, #, A-D 이외)가 입력되면 에러가 반환된다"
    - "DTMFReceived에서 타임아웃 내 digit 미수신 시 에러가 반환되고 failure 브랜치로 진행 가능하다"
    - "SendDTMF에서 각 digit 전송 사이에 intervalMs만큼 대기한다"
  artifacts:
    - path: "internal/engine/graph.go"
      provides: "GraphNode.Digits, GraphNode.IntervalMs, GraphNode.ExpectedDigit 필드 및 ParseScenario 파싱"
      contains: "Digits"
    - path: "internal/engine/executor.go"
      provides: "executeSendDTMF, executeDTMFReceived 메서드 및 isValidDTMF 헬퍼"
      contains: "executeSendDTMF"
  key_links:
    - from: "internal/engine/executor.go"
      to: "diago.DialogSession"
      via: "dialog.AudioWriterDTMF().WriteDTMF(digit) — RFC 2833 DTMF 전송"
      pattern: "AudioWriterDTMF"
    - from: "internal/engine/executor.go"
      to: "diago.DialogSession"
      via: "dialog.AudioReaderDTMF() — RFC 2833 DTMF 수신 + OnDTMF callback"
      pattern: "AudioReaderDTMF"
    - from: "internal/engine/executor.go"
      to: "internal/engine/graph.go"
      via: "node.Digits, node.IntervalMs, node.ExpectedDigit 필드 참조"
      pattern: "node\\.Digits"
---

<objective>
SendDTMF Command와 DTMFReceived Event의 Go 백엔드 실행 로직 구현: GraphNode 필드 확장, executor switch 케이스 추가, diago DTMF API 연동.

Purpose: 사용자가 시나리오에서 DTMF digit 송수신 노드를 실행할 수 있는 백엔드 기반을 제공한다.
Output: executor.go에 executeSendDTMF/executeDTMFReceived 메서드, graph.go에 DTMF 관련 필드 파싱.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-dtmf-send-receive/08-RESEARCH.md
@internal/engine/graph.go
@internal/engine/executor.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: GraphNode DTMF 필드 추가 + ParseScenario 파싱</name>
  <files>internal/engine/graph.go</files>
  <action>
GraphNode 구조체에 DTMF 관련 필드 3개를 추가한다:
- `Digits string` — SendDTMF용, "1234*#" 형식의 DTMF digit 문자열
- `IntervalMs float64` — SendDTMF용, digit 간 전송 간격 (기본값 100ms)
- `ExpectedDigit string` — DTMFReceived용, 대기할 특정 digit (빈 문자열이면 아무 digit 수신 시 완료)

GraphNode 구조체의 Command 주석을 업데이트: `MakeCall|Answer|Release|PlayAudio|SendDTMF`

ParseScenario 함수의 command 노드 파싱 블록(if node.Type == "command")에서 Digits와 IntervalMs를 파싱한다:
```go
gnode.Digits = getStringField(node.Data, "digits", "")
gnode.IntervalMs = getFloatField(node.Data, "intervalMs", 100)
```

ParseScenario 함수의 event 노드 파싱 블록(else if node.Type == "event")에서 ExpectedDigit를 파싱한다:
```go
gnode.ExpectedDigit = getStringField(node.Data, "expectedDigit", "")
```
  </action>
  <verify>
`cd /home/overthinker/Project/sipflow && go build ./...` — 컴파일 성공 확인.
`go vet ./internal/engine/...` — 정적 분석 통과.
graph.go에 Digits, IntervalMs, ExpectedDigit 필드가 존재하고 ParseScenario에서 파싱되는지 코드 확인.
  </verify>
  <done>GraphNode에 Digits, IntervalMs, ExpectedDigit 필드가 추가되고, ParseScenario에서 프론트엔드 JSON의 digits, intervalMs, expectedDigit 값을 정확히 파싱한다.</done>
</task>

<task type="auto">
  <name>Task 2: executeSendDTMF + executeDTMFReceived + isValidDTMF 구현</name>
  <files>internal/engine/executor.go</files>
  <action>
1. **executeCommand switch에 SendDTMF 케이스 추가:**
   기존 "PlayAudio" 케이스 아래에 `case "SendDTMF": return ex.executeSendDTMF(ctx, instanceID, node)` 추가.

2. **executeSendDTMF 메서드 구현:**
   - node.Digits가 빈 문자열이면 에러 반환: `fmt.Errorf("SendDTMF requires digits")`
   - node.IntervalMs에서 interval 계산 (time.Duration(node.IntervalMs) * time.Millisecond)
   - ex.sessions.GetDialog(instanceID)로 dialog 조회, 없으면 에러 반환 + emitActionLog("error")
   - dialog.AudioWriterDTMF()로 DTMF writer 생성
   - emitActionLog로 전송 시작 로깅 (digits 문자열 + interval 정보)
   - digits 문자열의 각 rune을 순회:
     - ctx.Done() 체크 (select default 패턴)
     - isValidDTMF(digit) 검증, 실패 시 에러 반환 + emitActionLog("error")
     - dtmfWriter.WriteDTMF(digit) 호출, 에러 시 반환 + emitActionLog("error")
     - emitActionLog로 개별 digit 전송 성공 로깅
     - 마지막 digit이 아니면 interval만큼 대기 (select ctx.Done 또는 time.After)
   - 전송 완료 emitActionLog("info")
   - nil 반환

3. **executeEvent switch에 DTMFReceived 케이스 추가:**
   기존 "TIMEOUT" 케이스 아래에 `case "DTMFReceived": return ex.executeDTMFReceived(ctx, instanceID, node)` 추가.

4. **executeDTMFReceived 메서드 구현:**
   - node.ExpectedDigit 파싱 (이미 GraphNode에 있음)
   - ex.sessions.GetDialog(instanceID)로 dialog 조회, 없으면 에러 반환 + emitActionLog("error")
   - dialog.AudioReaderDTMF()로 DTMF reader 생성
   - emitActionLog로 대기 상태 로깅 (expectedDigit 있으면 명시, 없으면 "any digit")
   - receivedCh (chan rune, 1)과 errCh (chan error, 1) 채널 생성
   - goroutine 시작:
     - dtmfReader.OnDTMF callback 설정:
       - expectedDigit이 설정되어 있고 digit != expectedDigit이면 emitActionLog("info")로 불일치 로깅 후 nil 반환 (계속 대기)
       - 매칭되면 receivedCh <- digit 전송 후 fmt.Errorf("digit received") 반환 (Listen 루프 중단)
     - Read 루프: buf := make([]byte, 1024), ctx.Done() 체크 + dtmfReader.Read(buf) 반복
     - Read 에러가 "digit received"면 정상 종료, 그 외는 errCh로 전달
   - select로 결과 대기:
     - ctx.Done() → ctx.Err() 반환
     - receivedCh → emitActionLog("info") + nil 반환
     - errCh → emitActionLog("error") + 에러 반환
     - time.After(node.Timeout) → emitActionLog("warning") + timeout 에러 반환

5. **isValidDTMF 헬퍼 함수 추가:**
   - rune 입력, bool 반환
   - '0'-'9', '*', '#', 'A'-'D' 허용, 나머지 false

연구에서 확인된 pitfall 주의:
- SDP 협상 전 DTMF 호출 불가 → GetDialog 존재 여부로 검증
- intervalMs 최소 50ms → 프론트엔드에서 강제 (백엔드는 받은 값 그대로 사용)
- goroutine leak 방지 → ctx.Done() 체크 필수
  </action>
  <verify>
`cd /home/overthinker/Project/sipflow && go build ./...` — 컴파일 성공.
`go vet ./internal/engine/...` — 정적 분석 통과.
`go test ./internal/engine/... -count=1` — 기존 테스트 통과 (회귀 없음).
executor.go에서 "SendDTMF", "DTMFReceived" case 존재 확인.
executeSendDTMF, executeDTMFReceived, isValidDTMF 함수 존재 확인.
  </verify>
  <done>
executor.go에 executeSendDTMF와 executeDTMFReceived 메서드가 구현되어 있고, executeCommand/executeEvent switch에 새 케이스가 추가되었다. isValidDTMF 헬퍼가 0-9, *, #, A-D를 검증한다. 기존 테스트가 통과한다.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` — 전체 프로젝트 빌드 성공
2. `go vet ./internal/engine/...` — 정적 분석 통과
3. `go test ./internal/engine/... -count=1` — 기존 테스트 회귀 없음
4. graph.go에 Digits, IntervalMs, ExpectedDigit 필드 존재
5. executor.go에 executeSendDTMF, executeDTMFReceived 메서드 존재
6. executor.go의 executeCommand switch에 "SendDTMF" 케이스 존재
7. executor.go의 executeEvent switch에 "DTMFReceived" 케이스 존재
8. isValidDTMF 함수가 0-9, *, #, A-D를 허용하고 나머지를 거부
</verification>

<success_criteria>
- Go 프로젝트 빌드 성공 (컴파일 에러 없음)
- SendDTMF Command 실행 로직이 diago AudioWriterDTMF API를 사용하여 digit 순차 전송
- DTMFReceived Event 실행 로직이 diago AudioReaderDTMF API를 사용하여 digit 수신 대기
- expectedDigit 필터링이 구현되어 특정 digit만 매칭
- context 취소 및 timeout 처리가 goroutine leak 방지
- 기존 테스트 통과 (회귀 없음)
</success_criteria>

<output>
완료 후, `.planning/phases/08-dtmf-send-receive/08-01-SUMMARY.md` 생성
</output>
