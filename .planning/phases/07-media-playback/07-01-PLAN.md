---
phase: 07-media-playback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/binding/media_binding.go
  - internal/engine/graph.go
  - internal/engine/executor.go
  - app.go
  - main.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Go 백엔드에서 WAV 파일을 열어 8kHz mono PCM 포맷인지 검증할 수 있다"
    - "Wails 네이티브 파일 다이얼로그로 .wav 파일을 선택할 수 있다"
    - "통화 연결 상태에서 PlayAudio 노드 실행 시 diago PlaybackCreate/Play로 WAV 파일이 RTP 재생된다"
    - "파일이 존재하지 않으면 실행 시 에러가 발생하고 failure 브랜치 또는 시나리오 중단이 된다"
  artifacts:
    - path: "internal/binding/media_binding.go"
      provides: "MediaBinding Wails 바인딩 — SelectWAVFile, ValidateWAVFile"
      min_lines: 60
    - path: "internal/engine/executor.go"
      provides: "executePlayAudio 메서드 — diago PlaybackCreate/Play 호출"
      contains: "executePlayAudio"
    - path: "internal/engine/graph.go"
      provides: "GraphNode.FilePath 필드 및 ParseScenario에서 filePath 파싱"
      contains: "FilePath"
  key_links:
    - from: "internal/binding/media_binding.go"
      to: "github.com/go-audio/wav"
      via: "wav.NewDecoder → IsValidFile → ReadInfo → SampleRate/NumChans/AudioFormat 검증"
      pattern: "wav\\.NewDecoder"
    - from: "internal/engine/executor.go"
      to: "diago.DialogSession"
      via: "dialog.PlaybackCreate() → pb.Play(file, audio/wav)"
      pattern: "PlaybackCreate"
    - from: "app.go"
      to: "internal/binding/media_binding.go"
      via: "mediaBinding 필드 + Bind 배열 등록"
      pattern: "mediaBinding"
---

<objective>
PlayAudio Command 노드의 Go 백엔드 전체 구현: WAV 파일 검증 바인딩, 파일 선택 다이얼로그, 실행 엔진 PlayAudio 핸들러, Wails 바인딩 등록.

Purpose: 프론트엔드가 호출할 수 있는 완전한 백엔드 API를 제공하여, WAV 파일 선택/검증/RTP 재생 파이프라인을 구축한다.
Output: MediaBinding (SelectWAVFile, ValidateWAVFile), executePlayAudio executor, GraphNode.FilePath 파싱, app.go 통합.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-media-playback/CONTEXT.md
@.planning/phases/07-media-playback/07-RESEARCH.md

@internal/engine/executor.go
@internal/engine/graph.go
@internal/engine/instance_manager.go
@internal/binding/engine_binding.go
@app.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: MediaBinding + WAV 검증 + 파일 다이얼로그</name>
  <files>
    internal/binding/media_binding.go
    go.mod
    go.sum
  </files>
  <action>
1. go-audio/wav 의존성 추가:
   ```
   go get github.com/go-audio/wav@latest
   ```

2. `internal/binding/media_binding.go` 신규 파일 생성 — 기존 `engine_binding.go` 패턴을 따른다:

   **MediaBinding 구조체:**
   - `ctx context.Context` 필드
   - `NewMediaBinding() *MediaBinding` 생성자
   - `SetContext(ctx context.Context)` Wails 라이프사이클 메서드

   **WAVValidationResult 타입:**
   ```go
   type WAVValidationResult struct {
       Valid    bool   `json:"valid"`
       Error    string `json:"error,omitempty"`
       Details  string `json:"details,omitempty"`
   }
   ```

   **ValidateWAVFile(filePath string) (*WAVValidationResult, error):**
   - `os.Open(filePath)` → 파일 열기 실패 시 `{Valid: false, Error: "Cannot open file: ..."}`
   - `wav.NewDecoder(f)` → `decoder.IsValidFile()` → 유효하지 않으면 `{Valid: false, Error: "Not a valid WAV file"}`
   - `decoder.ReadInfo()` 호출 후:
     - `decoder.SampleRate != 8000` → `{Valid: false, Error: "Sample rate must be 8kHz (file is X Hz)"}`
     - `decoder.NumChans != 1` → `{Valid: false, Error: "Must be mono (file has X channels)"}`
     - `decoder.Format().AudioFormat != 1` → `{Valid: false, Error: "Audio format must be PCM"}`
   - 모두 통과: `{Valid: true, Details: "8kHz mono PCM, X-bit"}`
   - `defer f.Close()` 반드시 포함
   - `runtime.LogInfo` / `runtime.LogWarning`으로 Wails 로깅

   **SelectWAVFile() (string, error):**
   - `runtime.OpenFileDialog(m.ctx, runtime.OpenDialogOptions{...})` 호출
   - FileFilter: `{DisplayName: "WAV Audio (*.wav)", Pattern: "*.wav"}`
   - 사용자 취소 시 빈 문자열 반환 (에러 아님)
   - 선택 후 즉시 `m.ValidateWAVFile(selected)` 호출하여 검증
   - 검증 실패 시 `fmt.Errorf(result.Error)` 반환 → 프론트엔드에서 toast로 표시
   - 검증 성공 시 절대 경로 문자열 반환

   **중요:** go-audio/wav decoder 사용 순서 — NewDecoder → IsValidFile → ReadInfo → 필드 접근. 이 순서를 반드시 지켜야 한다. ReadInfo 전에 SampleRate에 접근하면 0이 된다.
  </action>
  <verify>
    `go build ./...` 성공. `go vet ./internal/binding/...` 경고 없음.
  </verify>
  <done>
    MediaBinding이 ValidateWAVFile과 SelectWAVFile 두 개의 Wails 바인딩 메서드를 노출하고, go-audio/wav로 8kHz mono PCM 검증을 수행한다. 검증 실패 시 구체적 에러 메시지를 반환한다.
  </done>
</task>

<task type="auto">
  <name>Task 2: GraphNode FilePath + executePlayAudio + App 통합</name>
  <files>
    internal/engine/graph.go
    internal/engine/executor.go
    app.go
    main.go
  </files>
  <action>
1. **graph.go — GraphNode에 FilePath 필드 추가:**
   - `GraphNode` 구조체에 `FilePath string` 필드 추가 (TargetURI 옆에)
   - `ParseScenario()` 내 command 파싱 블록에서:
     ```go
     gnode.FilePath = getStringField(node.Data, "filePath", "")
     ```
   - TargetURI 파싱 라인 바로 아래에 추가. 기존 패턴 동일.

2. **executor.go — executePlayAudio 메서드 추가:**
   - `executeCommand` switch에 `"PlayAudio"` case 추가:
     ```go
     case "PlayAudio":
         return ex.executePlayAudio(ctx, instanceID, node)
     ```

   - `executePlayAudio(ctx context.Context, instanceID string, node *GraphNode) error` 구현:
     1. `node.FilePath`에서 경로 읽기 (빈 문자열이면 에러: "PlayAudio requires filePath")
     2. `os.Stat(filePath)` — 파일 존재 확인. 없으면 에러 로그 + `fmt.Errorf("audio file not found: %s", filePath)` (failure 브랜치는 ExecuteChain이 처리)
     3. `ex.sessions.GetDialog(instanceID)` — dialog 없으면 에러: "no active dialog for PlayAudio (call must be answered first)"
     4. `os.Open(filePath)` + `defer file.Close()`
     5. `dialog.PlaybackCreate()` — 실패 시 에러 로그 + 에러 반환
     6. `filepath.Base(filePath)`로 파일명 추출, `emitActionLog` "Playing audio file: {filename}" info
     7. context 취소 체크: `select { case <-ctx.Done(): return ctx.Err() default: }`
     8. `pb.Play(file, "audio/wav")` — blocking 호출, 완료 대기
     9. 완료 시 `emitActionLog` "Playback completed" info
     10. `return nil`

   - import 추가: `"os"`, `"path/filepath"`

   **중요 주의사항:**
   - Play() 호출 전 반드시 context 취소를 체크한다 (사용자가 StopScenario 호출 시)
   - dialog.PlaybackCreate()는 SDP 협상 완료 후에만 호출 가능 (Answer 이후)
   - Play()는 blocking이므로, 이 함수 자체가 재생 완료까지 블로킹된다

3. **app.go — MediaBinding 통합:**
   - App 구조체에 `mediaBinding *binding.MediaBinding` 필드 추가
   - `NewApp()`에서 `binding.NewMediaBinding()` 생성 → `mediaBinding` 필드에 저장
   - `startup()`에서 `a.mediaBinding.SetContext(ctx)` 호출

4. **main.go — Wails Bind 배열에 등록:**
   - `Bind` 배열에 `app.mediaBinding` 추가 (기존 `app.scenarioBinding` 아래)
  </action>
  <verify>
    `go build ./...` 성공. `go test ./internal/engine/...` 기존 테스트 통과 (회귀 없음). main.go에서 `app.mediaBinding`이 Bind 배열에 포함됨 확인.
  </verify>
  <done>
    1. GraphNode.FilePath가 ParseScenario에서 파싱된다.
    2. executeCommand에 "PlayAudio" case가 추가되어 executePlayAudio를 호출한다.
    3. executePlayAudio가 파일 존재 확인 → dialog 세션 확인 → PlaybackCreate → Play 파이프라인을 실행한다.
    4. MediaBinding이 Wails 바인딩으로 등록되어 프론트엔드에서 SelectWAVFile/ValidateWAVFile을 호출할 수 있다.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` — 전체 빌드 성공
2. `go test ./internal/engine/...` — 기존 테스트 전부 통과 (graph_test.go 포함)
3. `go vet ./...` — 정적 분석 경고 없음
4. `grep -n "PlayAudio" internal/engine/executor.go` — executePlayAudio 존재 확인
5. `grep -n "SelectWAVFile\|ValidateWAVFile" internal/binding/media_binding.go` — 바인딩 메서드 존재 확인
6. `grep -n "mediaBinding" main.go` — Wails Bind 배열에 등록 확인
</verification>

<success_criteria>
- go-audio/wav가 go.mod에 추가됨
- MediaBinding이 WAV 파일 검증 (8kHz mono PCM)과 파일 선택 다이얼로그를 제공
- GraphNode.FilePath가 flow_data에서 파싱됨
- executePlayAudio가 diago PlaybackCreate/Play로 WAV RTP 재생 수행
- MediaBinding이 Wails 바인딩으로 등록되어 프론트엔드 호출 가능
- 기존 테스트 회귀 없음
</success_criteria>

<output>
완료 후, `.planning/phases/07-media-playback/07-01-SUMMARY.md` 생성
</output>
