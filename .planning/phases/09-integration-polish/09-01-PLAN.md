---
phase: 09-integration-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/engine/executor_test.go
  - internal/engine/graph_test.go
  - internal/engine/instance_manager_test.go
  - internal/engine/integration_test.go
  - internal/binding/media_binding_test.go
autonomous: true

must_haves:
  truths:
    - "isValidDTMF 함수에 대한 단위 테스트가 존재하고, 유효 문자(0-9, *, #, A-D)와 무효 문자(@, E, a, 공백 등)를 모두 검증한다"
    - "stringToCodecs 함수에 대한 단위 테스트가 존재하고, PCMU/PCMA 변환 및 telephone-event 자동 추가를 검증한다"
    - "ValidateWAVFile 함수에 대한 단위 테스트가 존재하고, 유효한 8kHz mono PCM WAV와 유효하지 않은 파일을 검증한다"
    - "executePlayAudio/executeSendDTMF/executeDTMFReceived의 에러 경로(dialog 없음, 파일 없음, digits 없음)에 대한 테스트가 존재한다"
    - "ParseScenario가 PlayAudio(filePath), SendDTMF(digits, intervalMs), DTMFReceived(expectedDigit) 필드를 정확히 파싱하는 테스트가 존재한다"
    - "v1.0 호환 시나리오(MakeCall→Answer→Release, codecs 필드 없음)가 ParseScenario에서 정상 파싱되는 통합 테스트가 존재한다"
    - "모든 기존 테스트가 회귀 없이 통과한다"
    - "NF-01: PlayAudio/SendDTMF/DTMFReceived 노드가 기존 Command/Event 패턴과 아이콘, 색상, 드래그앤드롭 일관성이 검증된다 (코드 레벨 확인)"
    - "성공기준 4: E2E 테스트는 diago localhost 포트 충돌 제약으로 시뮬레이션 통합 테스트로 대체됨. 실 SIP 서버 E2E는 Phase 9 완료 후 수동 검증"
  artifacts:
    - path: "internal/engine/executor_test.go"
      provides: "isValidDTMF 단위 테스트, executePlayAudio/SendDTMF/DTMFReceived 에러 경로 테스트"
      contains: "TestIsValidDTMF"
    - path: "internal/engine/graph_test.go"
      provides: "ParseScenario DTMF/Media 필드 파싱 테스트"
      contains: "TestParseScenario_PlayAudioFields"
    - path: "internal/engine/instance_manager_test.go"
      provides: "stringToCodecs 단위 테스트"
      contains: "TestStringToCodecs"
    - path: "internal/engine/integration_test.go"
      provides: "v1.0 호환성 통합 테스트"
      contains: "TestIntegration_V1_0_Compatibility"
    - path: "internal/binding/media_binding_test.go"
      provides: "ValidateWAVFile 단위 테스트"
      contains: "TestValidateWAVFile"
  key_links:
    - from: "internal/engine/executor_test.go"
      to: "internal/engine/executor.go"
      via: "isValidDTMF 함수 직접 테스트 + Executor 에러 경로 테스트"
      pattern: "isValidDTMF"
    - from: "internal/engine/instance_manager_test.go"
      to: "internal/engine/instance_manager.go"
      via: "stringToCodecs 함수 직접 테스트"
      pattern: "stringToCodecs"
    - from: "internal/binding/media_binding_test.go"
      to: "internal/binding/media_binding.go"
      via: "ValidateWAVFile 메서드 테스트 (go-audio/wav 디코더 검증)"
      pattern: "ValidateWAVFile"
---

<objective>
미디어/DTMF 관련 Go 코드에 단위 테스트와 통합 테스트를 추가하여 NF-02(테스트 커버리지 70%+)와 NF-03(v1.0 회귀 방지)을 충족한다.

Purpose: 새 미디어 기능(PlayAudio, SendDTMF, DTMFReceived)의 안정성을 테스트로 보장하고, 기존 v1.0 시나리오와의 하위 호환성을 검증한다.
Output: 5개 테스트 파일에 단위 테스트, 에러 경로 테스트, 통합 테스트 추가. 전체 테스트 통과.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-integration-polish/09-RESEARCH.md
@internal/engine/executor.go
@internal/engine/executor_test.go
@internal/engine/graph.go
@internal/engine/graph_test.go
@internal/engine/instance_manager.go
@internal/engine/instance_manager_test.go
@internal/engine/integration_test.go
@internal/engine/engine.go
@internal/engine/events.go
@internal/binding/media_binding.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: isValidDTMF 단위 테스트</name>
  <files>internal/engine/executor_test.go</files>
  <action>
executor_test.go에 isValidDTMF 함수의 경계값 단위 테스트를 추가한다.

테스트 함수: `TestIsValidDTMF`

테이블 드리븐 테스트로 다음 케이스를 검증:
- **유효 문자**: '0', '1', '5', '9' (숫자 범위), '*', '#' (특수문자), 'A', 'B', 'C', 'D' (RFC 2833 확장)
- **무효 문자**: 'E', 'a', 'b', '@', ' ' (공백), '!' (특수문자), 'Z', 0 (null rune)

```go
func TestIsValidDTMF(t *testing.T) {
    tests := []struct {
        name     string
        input    rune
        expected bool
    }{
        // 유효 문자
        {"digit 0", '0', true},
        {"digit 1", '1', true},
        {"digit 5", '5', true},
        {"digit 9", '9', true},
        {"star", '*', true},
        {"hash", '#', true},
        {"letter A", 'A', true},
        {"letter B", 'B', true},
        {"letter C", 'C', true},
        {"letter D", 'D', true},
        // 무효 문자
        {"letter E", 'E', false},
        {"lowercase a", 'a', false},
        {"lowercase b", 'b', false},
        {"at sign", '@', false},
        {"space", ' ', false},
        {"exclamation", '!', false},
        {"letter Z", 'Z', false},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := isValidDTMF(tt.input)
            if result != tt.expected {
                t.Errorf("isValidDTMF(%c) = %v, expected %v", tt.input, result, tt.expected)
            }
        })
    }
}
```

참고: isValidDTMF는 executor.go L617-627에 위치한 패키지 내부 함수(소문자 시작)이므로 같은 package engine 내에서 직접 호출 가능.
  </action>
  <verify>
`cd /home/overthinker/Project/sipflow && go test ./internal/engine/... -run TestIsValidDTMF -v -count=1` — 모든 서브테스트 PASS.
  </verify>
  <done>isValidDTMF의 유효/무효 문자 17개 케이스가 테이블 드리븐 테스트로 검증된다.</done>
</task>

<task type="auto">
  <name>Task 2: stringToCodecs 단위 테스트</name>
  <files>internal/engine/instance_manager_test.go</files>
  <action>
instance_manager_test.go에 stringToCodecs 함수의 단위 테스트를 추가한다.

테스트 함수: `TestStringToCodecs`

검증 케이스:
1. **기본 코덱**: `["PCMU", "PCMA"]` → 결과 길이 3 (PCMU + PCMA + telephone-event), 순서 검증
2. **단일 코덱**: `["PCMU"]` → 결과 길이 2 (PCMU + telephone-event)
3. **빈 배열**: `[]` → 결과 길이 1 (telephone-event만)
4. **잘못된 코덱 이름**: `["INVALID", "PCMU"]` → INVALID 무시, 결과 길이 2 (PCMU + telephone-event)
5. **telephone-event 항상 마지막**: 모든 케이스에서 마지막 원소가 media.CodecTelephoneEvent8000

```go
func TestStringToCodecs(t *testing.T) {
    tests := []struct {
        name          string
        input         []string
        expectedLen   int
        lastIsTelEvt  bool
    }{
        {"PCMU and PCMA", []string{"PCMU", "PCMA"}, 3, true},
        {"PCMU only", []string{"PCMU"}, 2, true},
        {"empty", []string{}, 1, true},
        {"invalid codec ignored", []string{"INVALID", "PCMU"}, 2, true},
        {"all invalid", []string{"INVALID", "UNKNOWN"}, 1, true},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := stringToCodecs(tt.input)
            if len(result) != tt.expectedLen {
                t.Errorf("stringToCodecs(%v): expected %d codecs, got %d", tt.input, tt.expectedLen, len(result))
            }
            if tt.lastIsTelEvt && len(result) > 0 {
                last := result[len(result)-1]
                if last != media.CodecTelephoneEvent8000 {
                    t.Errorf("stringToCodecs(%v): last codec should be CodecTelephoneEvent8000", tt.input)
                }
            }
        })
    }
}
```

주의: `"github.com/emiago/diago/media"` import 추가 필요. stringToCodecs는 instance_manager.go에 패키지 내부 함수로 정의되어 있으므로 같은 패키지에서 직접 호출 가능.
  </action>
  <verify>
`cd /home/overthinker/Project/sipflow && go test ./internal/engine/... -run TestStringToCodecs -v -count=1` — 5개 서브테스트 모두 PASS.
  </verify>
  <done>stringToCodecs의 코덱 변환, 잘못된 이름 무시, telephone-event 자동 추가가 5개 케이스로 검증된다.</done>
</task>

<task type="auto">
  <name>Task 3: ValidateWAVFile 단위 테스트</name>
  <files>internal/binding/media_binding_test.go</files>
  <action>
새 파일 `internal/binding/media_binding_test.go`를 생성하여 ValidateWAVFile의 단위 테스트를 작성한다.

**주의**: ValidateWAVFile은 MediaBinding 메서드이고 내부에서 `runtime.LogInfo(m.ctx, ...)` 를 호출한다. Wails runtime은 테스트 환경에서 사용 불가하므로, ValidateWAVFile의 핵심 로직을 직접 테스트하는 대안 전략을 사용한다.

**전략**: ValidateWAVFile 메서드는 Wails runtime.LogInfo 의존성 때문에 직접 호출이 어렵다. 따라서 순수 WAV 검증 로직을 별도 함수로 추출하거나, go-audio/wav 디코더를 직접 테스트하는 패턴을 사용한다.

**접근법**: media_binding.go에서 WAV 검증 핵심 로직을 `validateWAVFormat(filePath string) *WAVValidationResult` 내부 함수로 추출하고, ValidateWAVFile에서 이를 호출하도록 리팩토링한다. 테스트는 추출된 함수를 직접 검증한다.

1. **media_binding.go 리팩토링**:
   - 기존 ValidateWAVFile에서 WAV 파일 열기 + go-audio/wav 디코더 검증 로직을 `validateWAVFormat(filePath string) *WAVValidationResult` 패키지 내부 함수로 추출
   - ValidateWAVFile은 runtime.LogInfo 호출 후 validateWAVFormat을 호출하는 래퍼로 변경

```go
// media_binding.go에 추가할 함수
func validateWAVFormat(filePath string) *WAVValidationResult {
    f, err := os.Open(filePath)
    if err != nil {
        return &WAVValidationResult{
            Valid: false,
            Error: fmt.Sprintf("Cannot open file: %v", err),
        }
    }
    defer f.Close()

    decoder := wav.NewDecoder(f)
    if !decoder.IsValidFile() {
        return &WAVValidationResult{
            Valid: false,
            Error: "Not a valid WAV file",
        }
    }

    decoder.ReadInfo()

    if decoder.SampleRate != 8000 {
        return &WAVValidationResult{
            Valid: false,
            Error: fmt.Sprintf("Sample rate must be 8kHz (file is %d Hz)", decoder.SampleRate),
        }
    }

    if decoder.NumChans != 1 {
        return &WAVValidationResult{
            Valid: false,
            Error: fmt.Sprintf("Must be mono (file has %d channels)", decoder.NumChans),
        }
    }

    if decoder.WavAudioFormat != 1 {
        return &WAVValidationResult{
            Valid: false,
            Error: "Audio format must be PCM",
        }
    }

    return &WAVValidationResult{
        Valid:   true,
        Details: fmt.Sprintf("8kHz mono PCM, %d-bit", decoder.BitDepth),
    }
}
```

ValidateWAVFile 메서드를 validateWAVFormat 호출로 변경:
```go
func (m *MediaBinding) ValidateWAVFile(filePath string) (*WAVValidationResult, error) {
    runtime.LogInfo(m.ctx, fmt.Sprintf("Validating WAV: %s", filePath))
    result := validateWAVFormat(filePath)
    if result.Valid {
        runtime.LogInfo(m.ctx, "WAV validation passed")
    }
    return result, nil
}
```

2. **media_binding_test.go 테스트 작성**:

테스트용 WAV 파일은 go-audio/wav 패키지로 프로그래밍 방식으로 생성한다 (외부 파일 의존 없음).

검증 케이스:
- **유효한 WAV**: 8kHz, mono, 16-bit PCM → Valid=true
- **존재하지 않는 파일**: → Valid=false, Error 에 "Cannot open file" 포함
- **비 WAV 파일**: 텍스트 파일 → Valid=false, Error에 "Not a valid WAV" 포함
- **잘못된 샘플레이트**: 44.1kHz WAV → Valid=false, Error에 "8kHz" 포함
- **스테레오**: 2채널 WAV → Valid=false, Error에 "mono" 포함

```go
package binding

import (
    "os"
    "path/filepath"
    "testing"

    goaudio "github.com/go-audio/audio"
    "github.com/go-audio/wav"
)

// createTestWAV creates a minimal WAV file for testing
func createTestWAV(t *testing.T, dir string, name string, sampleRate int, numChans int, bitDepth int) string {
    t.Helper()
    path := filepath.Join(dir, name)
    f, err := os.Create(path)
    if err != nil {
        t.Fatalf("failed to create test WAV: %v", err)
    }
    defer f.Close()

    enc := wav.NewEncoder(f, sampleRate, bitDepth, numChans, 1) // audioFormat=1 (PCM)
    // Write a few samples
    buf := &goaudio.IntBuffer{
        Data:           make([]int, sampleRate*numChans), // 1 second of silence
        Format:         &goaudio.Format{SampleRate: sampleRate, NumChannels: numChans},
        SourceBitDepth: bitDepth,
    }
    if err := enc.Write(buf); err != nil {
        t.Fatalf("failed to write WAV data: %v", err)
    }
    if err := enc.Close(); err != nil {
        t.Fatalf("failed to close WAV encoder: %v", err)
    }
    return path
}

func TestValidateWAVFormat_Valid8kHzMono(t *testing.T) {
    dir := t.TempDir()
    path := createTestWAV(t, dir, "valid.wav", 8000, 1, 16)

    result := validateWAVFormat(path)
    if !result.Valid {
        t.Errorf("expected Valid=true, got error: %s", result.Error)
    }
    if result.Details == "" {
        t.Error("expected non-empty Details for valid WAV")
    }
}

func TestValidateWAVFormat_FileNotFound(t *testing.T) {
    result := validateWAVFormat("/nonexistent/path/test.wav")
    if result.Valid {
        t.Error("expected Valid=false for non-existent file")
    }
    if result.Error == "" {
        t.Error("expected non-empty Error")
    }
}

func TestValidateWAVFormat_NotWAV(t *testing.T) {
    dir := t.TempDir()
    path := filepath.Join(dir, "not-wav.wav")
    os.WriteFile(path, []byte("this is not a wav file"), 0644)

    result := validateWAVFormat(path)
    if result.Valid {
        t.Error("expected Valid=false for non-WAV file")
    }
}

func TestValidateWAVFormat_Wrong_SampleRate(t *testing.T) {
    dir := t.TempDir()
    path := createTestWAV(t, dir, "44100hz.wav", 44100, 1, 16)

    result := validateWAVFormat(path)
    if result.Valid {
        t.Error("expected Valid=false for 44.1kHz WAV")
    }
    if result.Error == "" || !strings.Contains(result.Error, "8kHz") {
        t.Errorf("expected error mentioning 8kHz, got: %s", result.Error)
    }
}

func TestValidateWAVFormat_Stereo(t *testing.T) {
    dir := t.TempDir()
    path := createTestWAV(t, dir, "stereo.wav", 8000, 2, 16)

    result := validateWAVFormat(path)
    if result.Valid {
        t.Error("expected Valid=false for stereo WAV")
    }
    if result.Error == "" || !strings.Contains(result.Error, "mono") {
        t.Errorf("expected error mentioning mono, got: %s", result.Error)
    }
}
```

참고: "strings" 패키지 import 추가 필요.
  </action>
  <verify>
`cd /home/overthinker/Project/sipflow && go build ./internal/binding/...` — 리팩토링된 media_binding.go 컴파일 성공.
`cd /home/overthinker/Project/sipflow && go test ./internal/binding/... -v -count=1` — 5개 ValidateWAVFormat 테스트 모두 PASS.
  </verify>
  <done>ValidateWAVFile의 핵심 검증 로직이 validateWAVFormat으로 추출되고, 유효/무효 WAV 파일에 대한 5개 테스트가 통과한다.</done>
</task>

<task type="auto">
  <name>Task 4: executePlayAudio/SendDTMF/DTMFReceived 에러 경로 테스트</name>
  <files>internal/engine/executor_test.go</files>
  <action>
executor_test.go에 미디어/DTMF executor 함수의 에러 경로 테스트를 추가한다.

**테스트 전략**: Executor는 Engine(이벤트 발행용)과 InstanceManager(UA 조회용)에 의존한다. 에러 경로 테스트에서는 이벤트 발행을 위한 최소한의 Engine mock과 SessionStore를 직접 사용하여, dialog가 없는 상황에서의 에러 처리를 검증한다.

integration_test.go의 `newTestEngine` 패턴을 참고하여 테스트 환경을 구성한다.

1. **TestExecutePlayAudio_NoFilePath**: filePath가 빈 문자열인 노드 → "PlayAudio requires filePath" 에러
2. **TestExecutePlayAudio_FileNotFound**: 존재하지 않는 파일 경로 → "audio file not found" 에러
3. **TestExecutePlayAudio_NoDialog**: 유효한 파일 경로이지만 dialog가 없음 → "no active dialog" 에러
4. **TestExecuteSendDTMF_NoDigits**: digits가 빈 문자열 → "SendDTMF requires digits" 에러
5. **TestExecuteSendDTMF_NoDialog**: digits 있지만 dialog 없음 → "no active dialog" 에러
6. **TestExecuteDTMFReceived_NoDialog**: dialog 없음 → "no active dialog" 에러

**테스트 환경 구성**:
integration_test.go에 이미 정의된 `newTestEngine`과 `TestEventEmitter`를 활용한다. Executor는 `NewExecutor(engine, engine.im)`으로 생성하고, executeCommand/executeEvent를 호출할 수 없으므로(Engine.emitNodeState 의존), 직접 내부 메서드를 호출한다.

그러나 executePlayAudio/executeSendDTMF/executeDTMFReceived는 Executor의 비공개 메서드이므로 같은 패키지 내에서 직접 호출 가능하다.

```go
// 테스트 헬퍼: 최소한의 Executor 생성 (Engine 이벤트 발행 포함)
func newTestExecutor(t *testing.T) (*Executor, *TestEventEmitter) {
    t.Helper()
    dbPath := filepath.Join(t.TempDir(), "test.db")
    repo, err := scenario.NewRepository(dbPath)
    if err != nil {
        t.Fatal(err)
    }
    t.Cleanup(func() { repo.Close() })

    eng := NewEngine(repo)
    te := &TestEventEmitter{}
    eng.SetEventEmitter(te)

    executor := NewExecutor(eng, eng.im)
    return executor, te
}

func TestExecutePlayAudio_NoFilePath(t *testing.T) {
    ex, _ := newTestExecutor(t)
    node := &GraphNode{
        ID:       "test-node",
        Type:     "command",
        Command:  "PlayAudio",
        FilePath: "",
    }
    err := ex.executePlayAudio(context.Background(), "inst-1", node)
    if err == nil {
        t.Fatal("expected error for empty filePath")
    }
    if !strings.Contains(err.Error(), "requires filePath") {
        t.Errorf("expected 'requires filePath' error, got: %v", err)
    }
}

func TestExecutePlayAudio_FileNotFound(t *testing.T) {
    ex, _ := newTestExecutor(t)
    node := &GraphNode{
        ID:       "test-node",
        Type:     "command",
        Command:  "PlayAudio",
        FilePath: "/nonexistent/path/audio.wav",
    }
    err := ex.executePlayAudio(context.Background(), "inst-1", node)
    if err == nil {
        t.Fatal("expected error for non-existent file")
    }
    if !strings.Contains(err.Error(), "audio file not found") {
        t.Errorf("expected 'audio file not found' error, got: %v", err)
    }
}

func TestExecutePlayAudio_NoDialog(t *testing.T) {
    ex, _ := newTestExecutor(t)
    // 실제 파일 생성 (빈 파일이지만 존재함)
    tmpFile := filepath.Join(t.TempDir(), "test.wav")
    os.WriteFile(tmpFile, []byte("fake wav content"), 0644)

    node := &GraphNode{
        ID:       "test-node",
        Type:     "command",
        Command:  "PlayAudio",
        FilePath: tmpFile,
    }
    err := ex.executePlayAudio(context.Background(), "inst-1", node)
    if err == nil {
        t.Fatal("expected error for missing dialog")
    }
    if !strings.Contains(err.Error(), "no active dialog") {
        t.Errorf("expected 'no active dialog' error, got: %v", err)
    }
}

func TestExecuteSendDTMF_NoDigits(t *testing.T) {
    ex, _ := newTestExecutor(t)
    node := &GraphNode{
        ID:      "test-node",
        Type:    "command",
        Command: "SendDTMF",
        Digits:  "",
    }
    err := ex.executeSendDTMF(context.Background(), "inst-1", node)
    if err == nil {
        t.Fatal("expected error for empty digits")
    }
    if !strings.Contains(err.Error(), "requires digits") {
        t.Errorf("expected 'requires digits' error, got: %v", err)
    }
}

func TestExecuteSendDTMF_NoDialog(t *testing.T) {
    ex, _ := newTestExecutor(t)
    node := &GraphNode{
        ID:      "test-node",
        Type:    "command",
        Command: "SendDTMF",
        Digits:  "123",
    }
    err := ex.executeSendDTMF(context.Background(), "inst-1", node)
    if err == nil {
        t.Fatal("expected error for missing dialog")
    }
    if !strings.Contains(err.Error(), "no active dialog") {
        t.Errorf("expected 'no active dialog' error, got: %v", err)
    }
}

func TestExecuteDTMFReceived_NoDialog(t *testing.T) {
    ex, _ := newTestExecutor(t)
    node := &GraphNode{
        ID:            "test-node",
        Type:          "event",
        Event:         "DTMFReceived",
        ExpectedDigit: "1",
        Timeout:       1 * time.Second,
    }
    err := ex.executeDTMFReceived(context.Background(), "inst-1", node)
    if err == nil {
        t.Fatal("expected error for missing dialog")
    }
    if !strings.Contains(err.Error(), "no active dialog") {
        t.Errorf("expected 'no active dialog' error, got: %v", err)
    }
}
```

추가 import 필요: `"context"`, `"os"`, `"path/filepath"`, `"strings"`, `"sipflow/internal/scenario"`.
  </action>
  <verify>
`cd /home/overthinker/Project/sipflow && go test ./internal/engine/... -run "TestExecutePlayAudio|TestExecuteSendDTMF|TestExecuteDTMFReceived" -v -count=1` — 6개 에러 경로 테스트 모두 PASS.
  </verify>
  <done>executePlayAudio (3개), executeSendDTMF (2개), executeDTMFReceived (1개) 에러 경로 테스트가 통과한다.</done>
</task>

<task type="auto">
  <name>Task 5: ParseScenario DTMF/Media 필드 파싱 테스트</name>
  <files>internal/engine/graph_test.go</files>
  <action>
graph_test.go에 PlayAudio, SendDTMF, DTMFReceived 노드의 필드 파싱 테스트를 추가한다.

기존 graph_test.go의 TestParseScenario_* 패턴을 따른다.

1. **TestParseScenario_PlayAudioFields**: PlayAudio command 노드의 filePath 파싱 검증

```go
func TestParseScenario_PlayAudioFields(t *testing.T) {
    flowJSON := `{
  "nodes": [
    {
      "id": "inst-a",
      "type": "sipInstance",
      "position": {"x": 100, "y": 100},
      "data": {
        "label": "Instance A",
        "mode": "DN",
        "dn": "100",
        "register": true
      }
    },
    {
      "id": "cmd-play",
      "type": "command",
      "position": {"x": 100, "y": 250},
      "data": {
        "command": "PlayAudio",
        "sipInstanceId": "inst-a",
        "filePath": "/path/to/audio.wav",
        "timeout": 30000
      }
    }
  ],
  "edges": [
    {
      "id": "edge-1",
      "source": "inst-a",
      "target": "cmd-play",
      "sourceHandle": "success"
    }
  ]
}`

    graph, err := ParseScenario(flowJSON)
    if err != nil {
        t.Fatalf("ParseScenario failed: %v", err)
    }

    cmdPlay := graph.Nodes["cmd-play"]
    if cmdPlay == nil {
        t.Fatal("cmd-play not found")
    }

    if cmdPlay.Command != "PlayAudio" {
        t.Errorf("expected command PlayAudio, got %s", cmdPlay.Command)
    }
    if cmdPlay.FilePath != "/path/to/audio.wav" {
        t.Errorf("expected filePath '/path/to/audio.wav', got '%s'", cmdPlay.FilePath)
    }
    if cmdPlay.Timeout != 30*time.Second {
        t.Errorf("expected timeout 30s, got %v", cmdPlay.Timeout)
    }
}
```

2. **TestParseScenario_SendDTMFFields**: SendDTMF command 노드의 digits, intervalMs 파싱 검증

```go
func TestParseScenario_SendDTMFFields(t *testing.T) {
    flowJSON := `{
  "nodes": [
    {
      "id": "inst-a",
      "type": "sipInstance",
      "position": {"x": 100, "y": 100},
      "data": {
        "label": "Instance A",
        "mode": "DN",
        "dn": "100",
        "register": true
      }
    },
    {
      "id": "cmd-dtmf",
      "type": "command",
      "position": {"x": 100, "y": 250},
      "data": {
        "command": "SendDTMF",
        "sipInstanceId": "inst-a",
        "digits": "1234*#",
        "intervalMs": 200
      }
    }
  ],
  "edges": [
    {
      "id": "edge-1",
      "source": "inst-a",
      "target": "cmd-dtmf",
      "sourceHandle": "success"
    }
  ]
}`

    graph, err := ParseScenario(flowJSON)
    if err != nil {
        t.Fatalf("ParseScenario failed: %v", err)
    }

    cmdDTMF := graph.Nodes["cmd-dtmf"]
    if cmdDTMF == nil {
        t.Fatal("cmd-dtmf not found")
    }

    if cmdDTMF.Command != "SendDTMF" {
        t.Errorf("expected command SendDTMF, got %s", cmdDTMF.Command)
    }
    if cmdDTMF.Digits != "1234*#" {
        t.Errorf("expected digits '1234*#', got '%s'", cmdDTMF.Digits)
    }
    if cmdDTMF.IntervalMs != 200 {
        t.Errorf("expected intervalMs 200, got %f", cmdDTMF.IntervalMs)
    }
}
```

3. **TestParseScenario_SendDTMFDefaults**: intervalMs 기본값(100) 검증

```go
func TestParseScenario_SendDTMFDefaults(t *testing.T) {
    flowJSON := `{
  "nodes": [
    {
      "id": "inst-a",
      "type": "sipInstance",
      "position": {"x": 100, "y": 100},
      "data": {"label": "A", "mode": "DN", "dn": "100", "register": true}
    },
    {
      "id": "cmd-dtmf",
      "type": "command",
      "position": {"x": 100, "y": 250},
      "data": {
        "command": "SendDTMF",
        "sipInstanceId": "inst-a",
        "digits": "1"
      }
    }
  ],
  "edges": [
    {"id": "e1", "source": "inst-a", "target": "cmd-dtmf", "sourceHandle": "success"}
  ]
}`

    graph, err := ParseScenario(flowJSON)
    if err != nil {
        t.Fatalf("ParseScenario failed: %v", err)
    }

    cmdDTMF := graph.Nodes["cmd-dtmf"]
    if cmdDTMF.IntervalMs != 100 {
        t.Errorf("expected default intervalMs 100, got %f", cmdDTMF.IntervalMs)
    }
}
```

4. **TestParseScenario_DTMFReceivedFields**: DTMFReceived event 노드의 expectedDigit 파싱 검증

```go
func TestParseScenario_DTMFReceivedFields(t *testing.T) {
    flowJSON := `{
  "nodes": [
    {
      "id": "inst-a",
      "type": "sipInstance",
      "position": {"x": 100, "y": 100},
      "data": {"label": "A", "mode": "DN", "dn": "100", "register": true}
    },
    {
      "id": "evt-dtmf",
      "type": "event",
      "position": {"x": 100, "y": 250},
      "data": {
        "event": "DTMFReceived",
        "sipInstanceId": "inst-a",
        "expectedDigit": "5",
        "timeout": 15000
      }
    }
  ],
  "edges": [
    {"id": "e1", "source": "inst-a", "target": "evt-dtmf", "sourceHandle": "success"}
  ]
}`

    graph, err := ParseScenario(flowJSON)
    if err != nil {
        t.Fatalf("ParseScenario failed: %v", err)
    }

    evtDTMF := graph.Nodes["evt-dtmf"]
    if evtDTMF == nil {
        t.Fatal("evt-dtmf not found")
    }

    if evtDTMF.Event != "DTMFReceived" {
        t.Errorf("expected event DTMFReceived, got %s", evtDTMF.Event)
    }
    if evtDTMF.ExpectedDigit != "5" {
        t.Errorf("expected expectedDigit '5', got '%s'", evtDTMF.ExpectedDigit)
    }
    if evtDTMF.Timeout != 15*time.Second {
        t.Errorf("expected timeout 15s, got %v", evtDTMF.Timeout)
    }
}
```

5. **TestParseScenario_DTMFReceivedNoExpectedDigit**: expectedDigit 없이 파싱 (빈 문자열 기본값)

```go
func TestParseScenario_DTMFReceivedNoExpectedDigit(t *testing.T) {
    flowJSON := `{
  "nodes": [
    {
      "id": "inst-a",
      "type": "sipInstance",
      "position": {"x": 100, "y": 100},
      "data": {"label": "A", "mode": "DN", "dn": "100", "register": true}
    },
    {
      "id": "evt-dtmf",
      "type": "event",
      "position": {"x": 100, "y": 250},
      "data": {
        "event": "DTMFReceived",
        "sipInstanceId": "inst-a",
        "timeout": 5000
      }
    }
  ],
  "edges": [
    {"id": "e1", "source": "inst-a", "target": "evt-dtmf", "sourceHandle": "success"}
  ]
}`

    graph, err := ParseScenario(flowJSON)
    if err != nil {
        t.Fatalf("ParseScenario failed: %v", err)
    }

    evtDTMF := graph.Nodes["evt-dtmf"]
    if evtDTMF.ExpectedDigit != "" {
        t.Errorf("expected empty expectedDigit, got '%s'", evtDTMF.ExpectedDigit)
    }
}
```
  </action>
  <verify>
`cd /home/overthinker/Project/sipflow && go test ./internal/engine/... -run "TestParseScenario_PlayAudio|TestParseScenario_SendDTMF|TestParseScenario_DTMFReceived" -v -count=1` — 5개 테스트 모두 PASS.
기존 9개 ParseScenario 테스트도 여전히 통과:
`cd /home/overthinker/Project/sipflow && go test ./internal/engine/... -run TestParseScenario -v -count=1` — 14개 테스트 모두 PASS.
  </verify>
  <done>PlayAudio/SendDTMF/DTMFReceived 필드 파싱 테스트 5개가 추가되어 총 14개 ParseScenario 테스트가 통과한다.</done>
</task>

<task type="auto">
  <name>Task 6: v1.0 호환성 통합 테스트</name>
  <files>internal/engine/integration_test.go</files>
  <action>
integration_test.go에 v1.0 시나리오 포맷의 하위 호환성을 검증하는 통합 테스트를 추가한다.

기존 `TestIntegration_TwoPartyCallSimulation` 패턴을 참고하되, v1.0 포맷(codecs 필드 없음, 미디어 필드 없음)의 시나리오를 사용한다.

1. **TestIntegration_V1_0_Compatibility**: v1.0 포맷 시나리오가 정상 로드/파싱/실행되는지 검증

v1.0 시나리오 구조: Instance A(dn: 100) → TIMEOUT(500ms) → TIMEOUT(300ms), codecs 필드 없음.
실제 SIP 통화 없이 TIMEOUT 체인으로 실행 파이프라인만 검증.

```go
func TestIntegration_V1_0_Compatibility(t *testing.T) {
    eng, repo, te := newTestEngine(t, 23060)

    // v1.0 format: no codecs field, no media fields, no DTMF fields
    nodes := []FlowNode{
        {
            ID:   "inst-a",
            Type: "sipInstance",
            Data: map[string]interface{}{
                "label":    "v1.0 Instance",
                "mode":     "DN",
                "dn":       "100",
                "register": true,
                // Note: no "codecs" field — v1.0 format
            },
        },
        {
            ID:   "evt-timeout-1",
            Type: "event",
            Data: map[string]interface{}{
                "sipInstanceId": "inst-a",
                "event":         "TIMEOUT",
                "timeout":       500.0,
                // Note: no "expectedDigit" — v1.0 format
            },
        },
        {
            ID:   "evt-timeout-2",
            Type: "event",
            Data: map[string]interface{}{
                "sipInstanceId": "inst-a",
                "event":         "TIMEOUT",
                "timeout":       300.0,
            },
        },
    }

    edges := []FlowEdge{
        {ID: "e1", Source: "inst-a", Target: "evt-timeout-1"},
        {ID: "e2", Source: "evt-timeout-1", Target: "evt-timeout-2", SourceHandle: "success"},
    }

    flowData := buildTestFlowData(t, nodes, edges)

    // Verify ParseScenario handles v1.0 format
    graph, err := ParseScenario(flowData)
    if err != nil {
        t.Fatalf("ParseScenario failed for v1.0 format: %v", err)
    }

    // Verify codecs default applied
    instA := graph.Instances["inst-a"]
    if len(instA.Config.Codecs) != 2 || instA.Config.Codecs[0] != "PCMU" {
        t.Errorf("expected default codecs [PCMU, PCMA], got %v", instA.Config.Codecs)
    }

    // Create and run scenario
    scn, err := repo.CreateScenario("default", "v1-compat-test")
    if err != nil {
        t.Fatalf("CreateScenario failed: %v", err)
    }

    if err := repo.SaveScenario(scn.ID, flowData); err != nil {
        t.Fatalf("SaveScenario failed: %v", err)
    }

    if err := eng.StartScenario(scn.ID); err != nil {
        t.Fatalf("StartScenario failed: %v", err)
    }

    // Wait for completion (500ms + 300ms = ~800ms, with 5s timeout)
    if !waitForEvent(t, te, EventCompleted, 5*time.Second) {
        allEvents := te.GetEvents()
        for _, e := range allEvents {
            t.Logf("Event: %s - %+v", e.Name, e.Data)
        }
        t.Fatal("v1.0 scenario did not complete within 5 seconds")
    }

    // Verify all nodes completed
    if !waitForNodeState(t, te, "evt-timeout-1", NodeStateCompleted, 1*time.Second) {
        t.Error("evt-timeout-1 did not complete")
    }
    if !waitForNodeState(t, te, "evt-timeout-2", NodeStateCompleted, 1*time.Second) {
        t.Error("evt-timeout-2 did not complete")
    }

    // Verify scenario completed (no regression)
    completedEvents := te.GetEventsByName(EventCompleted)
    if len(completedEvents) != 1 {
        t.Errorf("expected 1 completed event, got %d", len(completedEvents))
    }

    time.Sleep(500 * time.Millisecond)
}
```

2. **TestIntegration_V1_0_MakeCallAnswerRelease_Parse**: v1.0의 전형적인 MakeCall→Answer→Release 시나리오가 ParseScenario에서 정상 파싱되는지 검증 (실행은 skip — diago 포트 충돌)

```go
func TestIntegration_V1_0_MakeCallAnswerRelease_Parse(t *testing.T) {
    // v1.0 typical scenario: MakeCall from A, INCOMING+Answer on B, Release on A
    // No codecs, no media, no DTMF fields
    nodes := []FlowNode{
        {
            ID:   "inst-a",
            Type: "sipInstance",
            Data: map[string]interface{}{
                "label":    "Caller",
                "mode":     "DN",
                "dn":       "100",
                "register": true,
            },
        },
        {
            ID:   "inst-b",
            Type: "sipInstance",
            Data: map[string]interface{}{
                "label":    "Callee",
                "mode":     "DN",
                "dn":       "200",
                "register": true,
            },
        },
        {
            ID:   "cmd-make",
            Type: "command",
            Data: map[string]interface{}{
                "sipInstanceId": "inst-a",
                "command":       "MakeCall",
                "targetUri":     "sip:200@127.0.0.1:5062",
            },
        },
        {
            ID:   "evt-incoming",
            Type: "event",
            Data: map[string]interface{}{
                "sipInstanceId": "inst-b",
                "event":         "INCOMING",
            },
        },
        {
            ID:   "cmd-answer",
            Type: "command",
            Data: map[string]interface{}{
                "sipInstanceId": "inst-b",
                "command":       "Answer",
            },
        },
        {
            ID:   "cmd-release",
            Type: "command",
            Data: map[string]interface{}{
                "sipInstanceId": "inst-a",
                "command":       "Release",
            },
        },
    }

    edges := []FlowEdge{
        {ID: "e1", Source: "inst-a", Target: "cmd-make"},
        {ID: "e2", Source: "cmd-make", Target: "cmd-release", SourceHandle: "success"},
        {ID: "e3", Source: "inst-b", Target: "evt-incoming"},
        {ID: "e4", Source: "evt-incoming", Target: "cmd-answer", SourceHandle: "success"},
    }

    flowData := buildTestFlowData(t, nodes, edges)

    graph, err := ParseScenario(flowData)
    if err != nil {
        t.Fatalf("ParseScenario failed for v1.0 MakeCall→Answer→Release: %v", err)
    }

    // Verify 2 instances
    if len(graph.Instances) != 2 {
        t.Errorf("expected 2 instances, got %d", len(graph.Instances))
    }

    // Verify 4 nodes
    if len(graph.Nodes) != 4 {
        t.Errorf("expected 4 nodes, got %d", len(graph.Nodes))
    }

    // Verify chain: inst-a -> cmd-make -> cmd-release
    cmdMake := graph.Nodes["cmd-make"]
    if cmdMake == nil {
        t.Fatal("cmd-make not found")
    }
    if cmdMake.Command != "MakeCall" {
        t.Errorf("expected MakeCall, got %s", cmdMake.Command)
    }
    if cmdMake.SuccessNext == nil || cmdMake.SuccessNext.ID != "cmd-release" {
        t.Error("cmd-make.SuccessNext should be cmd-release")
    }
    // Verify media fields have defaults (no filePath, no digits)
    if cmdMake.FilePath != "" {
        t.Errorf("expected empty filePath for v1.0 MakeCall, got '%s'", cmdMake.FilePath)
    }
    if cmdMake.Digits != "" {
        t.Errorf("expected empty digits for v1.0 MakeCall, got '%s'", cmdMake.Digits)
    }

    // Verify chain: inst-b -> evt-incoming -> cmd-answer
    evtIncoming := graph.Nodes["evt-incoming"]
    if evtIncoming == nil {
        t.Fatal("evt-incoming not found")
    }
    if evtIncoming.SuccessNext == nil || evtIncoming.SuccessNext.ID != "cmd-answer" {
        t.Error("evt-incoming.SuccessNext should be cmd-answer")
    }
    // Verify expectedDigit has default
    if evtIncoming.ExpectedDigit != "" {
        t.Errorf("expected empty expectedDigit for v1.0 INCOMING, got '%s'", evtIncoming.ExpectedDigit)
    }

    // Verify default codecs applied
    for _, chain := range graph.Instances {
        if len(chain.Config.Codecs) != 2 {
            t.Errorf("expected 2 default codecs, got %d for instance %s", len(chain.Config.Codecs), chain.Config.ID)
        }
    }
}
```
  </action>
  <verify>
`cd /home/overthinker/Project/sipflow && go test ./internal/engine/... -run "TestIntegration_V1_0" -v -count=1` — 2개 테스트 모두 PASS.
기존 통합 테스트도 회귀 없이 통과:
`cd /home/overthinker/Project/sipflow && go test ./internal/engine/... -count=1` — 전체 PASS.
  </verify>
  <done>v1.0 호환성 검증 통합 테스트 2개(실행 + 파싱)가 추가되어, 미디어 기능 추가 후에도 v1.0 시나리오가 정상 동작함을 확인한다.</done>
</task>

<task type="auto">
  <name>Task 7: 전체 테스트 실행, NF-01 검증 및 회귀 확인</name>
  <files></files>
  <action>
모든 테스트를 실행하여 회귀가 없는지 최종 확인하고, NF-01(UX 일관성)을 코드 레벨에서 검증한다.

1. 전체 Go 테스트 실행:
```bash
cd /home/overthinker/Project/sipflow && go test ./... -count=1 -timeout=120s
```

2. 정적 분석:
```bash
cd /home/overthinker/Project/sipflow && go vet ./...
```

3. 빌드 확인:
```bash
cd /home/overthinker/Project/sipflow && go build ./...
```

4. 테스트 커버리지 측정 (미디어/DTMF 관련 실제 파일 기준):

**주의**: `internal/media/` 패키지는 존재하지 않음. 미디어/DTMF 코드는 아래 파일에 분산되어 있으므로 개별 함수 기준으로 커버리지를 측정한다.

대상 파일 및 핵심 함수:
- `internal/engine/executor.go`: executePlayAudio, executeSendDTMF, executeDTMFReceived, isValidDTMF
- `internal/engine/instance_manager.go`: stringToCodecs
- `internal/engine/graph.go`: ParseScenario (DTMF/Media 필드 파싱)
- `internal/binding/media_binding.go`: ValidateWAVFile (→ validateWAVFormat)

```bash
cd /home/overthinker/Project/sipflow && go test ./internal/engine/... -coverprofile=coverage.out -count=1
cd /home/overthinker/Project/sipflow && go tool cover -func=coverage.out | grep -E "isValidDTMF|executePlayAudio|executeSendDTMF|executeDTMFReceived|stringToCodecs|ParseScenario"
cd /home/overthinker/Project/sipflow && go test ./internal/binding/... -coverprofile=binding_coverage.out -count=1
cd /home/overthinker/Project/sipflow && go tool cover -func=binding_coverage.out | grep -E "validateWAVFormat|ValidateWAVFile"
```

커버리지 목표: 위 함수들의 종합 커버리지 70%+ (NF-02 충족).

5. **NF-01 UX 일관성 검증 체크리스트** (코드 레벨 확인):

다음 항목을 코드에서 직접 확인하여 NF-01(UX 일관성)을 검증한다:

- [ ] **node-palette.tsx**: PlayAudio, SendDTMF가 기존 Command 노드(MakeCall, Answer, Release)와 동일한 `<PaletteItem>` 패턴 및 `colorClass="bg-blue-50 border-blue-400 text-blue-900"` 사용 확인
- [ ] **node-palette.tsx**: DTMFReceived가 기존 Event 노드(INCOMING, DISCONNECTED 등)와 동일한 `<PaletteItem>` 패턴 및 `colorClass="bg-amber-50 border-amber-400 text-amber-900"` 사용 확인
- [ ] **command-node.tsx**: `COMMAND_ICONS`에 `PlayAudio: Volume2`, `SendDTMF: Hash` 등록 확인
- [ ] **event-node.tsx**: `EVENT_ICONS`에 `DTMFReceived: Ear` 등록 확인
- [ ] **command-node.tsx**: Command 노드 색상 `bg-blue-50 border-2 border-blue-400` 확인 (PlayAudio/SendDTMF 포함 모든 command에 적용)
- [ ] **event-node.tsx**: Event 노드 색상 `bg-amber-50 border-2 border-amber-400` 확인 (DTMFReceived 포함 모든 event에 적용)
- [ ] **드래그앤드롭**: PlayAudio/SendDTMF/DTMFReceived가 PaletteItem으로 등록되어 기존 노드와 동일한 드래그앤드롭 동작을 공유함을 확인

검증 방법:
```bash
# PaletteItem 패턴 일관성 확인
grep -c "PaletteItem" frontend/src/features/scenario-builder/components/node-palette.tsx
# PlayAudio/SendDTMF가 command 색상 사용 확인
grep "PlayAudio\|SendDTMF" frontend/src/features/scenario-builder/components/node-palette.tsx | grep "bg-blue-50"
# DTMFReceived가 event 색상 사용 확인
grep "DTMFReceived" frontend/src/features/scenario-builder/components/node-palette.tsx | grep "bg-amber-50"
# COMMAND_ICONS에 PlayAudio/SendDTMF 등록 확인
grep -A5 "COMMAND_ICONS" frontend/src/features/scenario-builder/components/nodes/command-node.tsx | grep -E "PlayAudio|SendDTMF"
# EVENT_ICONS에 DTMFReceived 등록 확인
grep -A10 "EVENT_ICONS" frontend/src/features/scenario-builder/components/nodes/event-node.tsx | grep "DTMFReceived"
```

6. **성공기준 4 (E2E 테스트) 처리 확인**:

diago는 localhost에서 동일 포트로 복수 UA를 바인딩할 수 없는 물리적 제약이 있어, 실 SIP 서버 대상 자동 E2E 테스트는 불가능하다. 이를 다음과 같이 대체한다:
- Task 6의 `TestIntegration_V1_0_Compatibility`: TIMEOUT 체인을 사용한 시뮬레이션 통합 테스트로 실행 파이프라인 검증
- Task 6의 `TestIntegration_V1_0_MakeCallAnswerRelease_Parse`: v1.0 전형적 시나리오의 파싱 정합성 검증
- 실 SIP 서버 대상 E2E 테스트는 Phase 9 완료 후 수동으로 검증한다

실패한 테스트가 있으면 원인을 분석하고 수정한다.
  </action>
  <verify>
`go test ./... -count=1` — 전체 PASS (0 failures).
`go vet ./...` — 경고 없음.
`go build ./...` — 빌드 성공.
미디어/DTMF 핵심 함수(isValidDTMF, executePlayAudio, executeSendDTMF, executeDTMFReceived, stringToCodecs, ParseScenario, validateWAVFormat) 커버리지가 종합적으로 70% 이상 도달.
NF-01 체크리스트 전 항목 확인 완료 (PlayAudio/SendDTMF/DTMFReceived가 기존 패턴과 일관성 유지).
  </verify>
  <done>전체 Go 테스트가 회귀 없이 통과하고, 미디어/DTMF 핵심 함수의 테스트 커버리지가 70% 이상 달성되었으며, NF-01 UX 일관성이 코드 레벨에서 검증되었다.</done>
</task>

</tasks>

<verification>
1. `go test ./... -count=1` — 전체 프로젝트 테스트 통과 (0 failures)
2. `go vet ./...` — 정적 분석 통과
3. `go build ./...` — 빌드 성공
4. executor_test.go에 TestIsValidDTMF, TestExecutePlayAudio_*, TestExecuteSendDTMF_*, TestExecuteDTMFReceived_* 존재
5. graph_test.go에 TestParseScenario_PlayAudioFields, TestParseScenario_SendDTMFFields, TestParseScenario_DTMFReceivedFields 존재
6. instance_manager_test.go에 TestStringToCodecs 존재
7. media_binding_test.go에 TestValidateWAVFormat_* 존재
8. integration_test.go에 TestIntegration_V1_0_Compatibility, TestIntegration_V1_0_MakeCallAnswerRelease_Parse 존재
9. 미디어/DTMF 핵심 함수(executor.go, instance_manager.go, graph.go, media_binding.go) 커버리지 70%+ 달성
10. NF-01 검증: node-palette.tsx에서 PlayAudio/SendDTMF가 bg-blue-50/border-blue-400, DTMFReceived가 bg-amber-50/border-amber-400 사용 확인
11. NF-01 검증: command-node.tsx COMMAND_ICONS에 PlayAudio(Volume2)/SendDTMF(Hash), event-node.tsx EVENT_ICONS에 DTMFReceived(Ear) 등록 확인
12. 성공기준 4: 시뮬레이션 통합 테스트로 대체 완료 확인 (diago 포트 충돌 제약으로 실 SIP E2E는 Phase 9 완료 후 수동 검증)
</verification>

<success_criteria>
- isValidDTMF, stringToCodecs, validateWAVFormat 순수 함수에 100% 단위 테스트
- executePlayAudio/SendDTMF/DTMFReceived 에러 경로 테스트 6개 통과
- ParseScenario DTMF/Media 필드 파싱 테스트 5개 통과
- v1.0 호환성 통합 테스트 2개 통과 (NF-03 충족)
- 기존 테스트 전체 회귀 없이 통과
- 미디어/DTMF 핵심 함수(executor.go, instance_manager.go, graph.go, media_binding.go) 테스트 커버리지 70% 이상 (NF-02 충족)
- NF-01 UX 일관성: PlayAudio/SendDTMF/DTMFReceived가 기존 Command/Event 패턴과 아이콘, 색상, PaletteItem 일관성 코드 레벨 검증 완료
- 성공기준 4: diago 포트 충돌 제약으로 시뮬레이션 통합 테스트로 대체됨 (실 SIP E2E는 Phase 9 완료 후 수동 검증)
</success_criteria>

<output>
완료 후, `.planning/phases/09-integration-polish/09-01-SUMMARY.md` 생성
</output>
