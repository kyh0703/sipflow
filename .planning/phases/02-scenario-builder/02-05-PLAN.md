---
phase: 02-scenario-builder
plan: 05
title: "Scenario tree + CRUD integration (frontend-backend wiring)"
wave: 3
depends_on: [02, 03]
files_modified:
  - frontend/src/features/scenario-builder/components/ScenarioTree.tsx
  - frontend/src/features/scenario-builder/store/scenarioStore.ts
  - frontend/src/features/scenario-builder/hooks/useScenarioApi.ts
  - frontend/src/features/scenario-builder/components/ScenarioBuilder.tsx
  - frontend/src/features/scenario-builder/components/Canvas.tsx
autonomous: true

must_haves:
  truths:
    - "Scenario tree in left sidebar shows list of saved scenarios"
    - "Users can create a new scenario from the tree"
    - "Users can select a scenario to load it onto the canvas"
    - "Users can save the current canvas state to SQLite via Wails binding"
    - "Users can delete a scenario from the tree"
    - "Users can rename a scenario"
    - "Scenario data persists across app restarts"
  artifacts:
    - path: "frontend/src/features/scenario-builder/components/ScenarioTree.tsx"
      provides: "Scenario list with create/select/delete/rename actions"
    - path: "frontend/src/features/scenario-builder/hooks/useScenarioApi.ts"
      provides: "Hook wrapping Wails ScenarioBinding calls"
  key_links:
    - from: "useScenarioApi.ts"
      to: "wailsjs/go/binding/ScenarioBinding"
      via: "import { CreateScenario, SaveScenario, LoadScenario, ListScenarios, DeleteScenario, RenameScenario }"
    - from: "ScenarioTree.tsx"
      to: "useScenarioApi.ts"
      via: "calls API hook for CRUD operations"
    - from: "ScenarioTree.tsx"
      to: "scenarioStore.ts"
      via: "setNodes/setEdges when loading, clearCanvas when creating new"
    - from: "Canvas.tsx"
      to: "useScenarioApi.ts"
      via: "save trigger (Ctrl+S) serializes canvas to backend"
---

# Plan 02-05: Scenario tree + CRUD integration (frontend-backend wiring)

## Objective

Wire the frontend to the Go backend via Wails bindings. Build the scenario tree in the left sidebar for scenario management (create/load/save/delete/rename), and implement save/load serialization using React Flow's toObject() method.

Purpose: This connects the frontend canvas to persistent storage. Without this, all work is lost on app close.

Output: Full scenario CRUD: create, load, save (Ctrl+S), rename, delete. Scenario list in left sidebar. Data persists in SQLite.

## Tasks

<task id="05-T1">

### Task 1: Create scenario API hook and store integration

**Files to create:**
- `frontend/src/features/scenario-builder/hooks/useScenarioApi.ts`

**Files to modify:**
- `frontend/src/features/scenario-builder/store/scenarioStore.ts`

**Action:**

1. Create `useScenarioApi.ts`:
   - Import generated Wails bindings: `import { CreateScenario, SaveScenario, LoadScenario, ListScenarios, DeleteScenario, RenameScenario } from '../../../../wailsjs/go/binding/ScenarioBinding'`
   - Note: Wails generates TypeScript types in wailsjs/ — verify the exact import path after `wails dev` generates them. The path may be relative from the hooks directory.
   - Define `ScenarioListItem` interface matching Go struct: `{ id: string, projectId: string, name: string, createdAt: string, updatedAt: string }`
   - Define `ScenarioData` interface matching Go struct: `{ id: string, projectId: string, name: string, flowData: string, createdAt: string, updatedAt: string }`
   - Export hook `useScenarioApi()` returning:
     - `createScenario(name: string): Promise<ScenarioData>` — calls CreateScenario binding
     - `saveScenario(id: string, flowData: string): Promise<void>` — calls SaveScenario binding
     - `loadScenario(id: string): Promise<ScenarioData>` — calls LoadScenario binding
     - `listScenarios(): Promise<ScenarioListItem[]>` — calls ListScenarios binding
     - `deleteScenario(id: string): Promise<void>` — calls DeleteScenario binding
     - `renameScenario(id: string, newName: string): Promise<void>` — calls RenameScenario binding
   - Each function wraps the Wails call with try/catch and returns typed results

2. Update `scenarioStore.ts`:
   - Add `currentScenarioId: string | null` to state
   - Add `currentScenarioName: string | null` to state
   - Add `isDirty: boolean` to state (tracks unsaved changes)
   - Add `setCurrentScenario(id: string | null, name: string | null): void`
   - Add `setDirty(dirty: boolean): void`
   - Modify `onNodesChange`, `onEdgesChange`, `onConnect`, `addNode`, `removeNode`, `updateNodeData` to also call `setDirty(true)` when changes occur
   - Add `toFlowJSON(): string`: serialize current nodes/edges/viewport as JSON string using `{ nodes, edges }` from store
   - Add `loadFromJSON(json: string): void`: parse JSON, call setNodes/setEdges to restore state, setDirty(false)

### Acceptance Criteria
- useScenarioApi hook compiles and exports all 6 CRUD functions
- Store tracks currentScenarioId, currentScenarioName, isDirty
- Any canvas change (add/move/connect/delete) sets isDirty = true
- toFlowJSON serializes canvas state, loadFromJSON restores it
- `npx tsc --noEmit` passes
</task>

<task id="05-T2">

### Task 2: Build scenario tree UI + save/load keyboard shortcut

**Files to create:**
- `frontend/src/features/scenario-builder/components/ScenarioTree.tsx`

**Files to modify:**
- `frontend/src/features/scenario-builder/components/ScenarioBuilder.tsx`
- `frontend/src/features/scenario-builder/components/Canvas.tsx`

**Action:**

1. Create `ScenarioTree.tsx`:
   - Uses `useScenarioApi` and `useScenarioStore`
   - On mount (`useEffect`): call `listScenarios()` and store in local state
   - Display a flat list of scenarios (not a tree for now — Phase 2 is single project)
   - Each scenario item shows:
     - Name (clickable to load)
     - Active indicator (highlight if currentScenarioId matches)
     - Context menu or small icon buttons: Rename (Pencil icon), Delete (Trash icon)
   - "New Scenario" button at top with Plus icon:
     - Prompts for name (use window.prompt for simplicity, or an inline input)
     - Calls createScenario(name)
     - Auto-selects the new scenario (clears canvas, sets currentScenarioId)
     - Refreshes list
   - Click on scenario item:
     - If isDirty, show confirm dialog: "Unsaved changes. Save before switching?"
     - Load scenario: call loadScenario(id), parse flowData JSON, call store.loadFromJSON
     - Set currentScenarioId and currentScenarioName
   - Delete: confirm dialog, call deleteScenario(id), refresh list, if deleted was current -> clear canvas
   - Rename: inline edit or prompt, call renameScenario(id, newName), refresh list

2. Update `ScenarioBuilder.tsx`:
   - Replace the scenario tree placeholder in the left sidebar with `<ScenarioTree />`
   - Add a header bar above the 3-panel layout (thin, ~40px):
     - Show current scenario name (or "No scenario selected")
     - Show dirty indicator (dot or asterisk when isDirty)
     - Save button (floppy disk icon)

3. Update `Canvas.tsx`:
   - Add Ctrl+S / Cmd+S keyboard shortcut handler:
     - `useEffect` with `keydown` listener
     - On Ctrl/Cmd + S: prevent default, get currentScenarioId from store
     - If no current scenario: show alert "Create or select a scenario first"
     - If current scenario: serialize canvas with `toFlowJSON()`, call `saveScenario(id, json)`, set isDirty(false)
   - After successful save, optionally show a brief toast or change the title indicator

### Acceptance Criteria
- Left sidebar shows scenario list from SQLite
- "New Scenario" creates a new entry and clears canvas
- Clicking a scenario loads its flow data onto canvas
- Ctrl+S saves current canvas state to SQLite
- Delete removes scenario and refreshes list
- Rename updates scenario name
- Dirty indicator shows when unsaved changes exist
- Switching scenarios with unsaved changes shows confirm dialog
- Data persists: create scenario, add nodes, save, reload app -> nodes still there
- `npx tsc --noEmit` passes
</task>

## Verification

```bash
cd /Users/kyh0703/Project/sipflow/frontend && npx tsc --noEmit
```

Functional verification with `wails dev`:
1. Click "New Scenario" -> enter name -> scenario appears in list, canvas clears
2. Drag nodes onto canvas, connect them
3. Press Ctrl+S -> dirty indicator clears
4. Create second scenario -> canvas clears
5. Click first scenario -> nodes and edges are restored
6. Close and reopen app -> scenarios still listed, load works
7. Rename a scenario -> name updates in list
8. Delete a scenario -> removed from list

## Success Criteria

- Complete scenario CRUD via Wails bindings
- Scenario tree displays all saved scenarios
- Save (Ctrl+S) persists canvas state to SQLite
- Load restores complete canvas state (nodes, edges, positions)
- Dirty tracking warns before data loss
- Data survives app restart
