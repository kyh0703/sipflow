---
plan: "03-01"
title: "Engine 코어 데이터 구조 + 그래프 파서"
wave: 1
depends_on: []
files_modified:
  - internal/engine/graph.go
  - internal/engine/engine.go
  - internal/engine/events.go
  - internal/engine/graph_test.go
autonomous: true
estimated_tasks: 4
---

# Plan 03-01: Engine 코어 데이터 구조 + 그래프 파서

## 목표
Go 백엔드에서 시나리오를 실행하기 위한 핵심 데이터 구조와 그래프 파서를 구축한다. 프론트엔드의 FlowData JSON을 Go 실행 그래프(ExecutionGraph)로 변환하는 파서를 구현하고, Engine 타입의 기본 골격과 이벤트 발행 헬퍼를 생성한다.

## 컨텍스트
Phase 02에서 완성된 시나리오 빌더는 `scenario-store.ts`의 `toFlowJSON()`을 통해 `{nodes, edges}` JSON 문자열을 `scenario.Scenario.FlowData`에 저장한다. 이 JSON을 Go에서 파싱하여 인스턴스별 노드 체인으로 변환해야 한다. 이 계획은 Phase 03의 모든 후속 계획이 의존하는 기반 데이터 구조를 제공한다.

현재 `internal/engine/` 디렉토리에는 `.gitkeep` 파일만 존재하며, 새로운 파일을 생성해야 한다.

## 태스크

<task id="1">
<title>ExecutionGraph 및 GraphNode 데이터 구조 정의</title>
<instruction>
`internal/engine/graph.go` 파일을 생성한다. 프론트엔드 JSON 스키마에 대응하는 Go 타입들을 정의한다.

프론트엔드에서 저장하는 FlowData JSON 구조:
```json
{
  "nodes": [
    {"id": "...", "type": "sipInstance|command|event", "position": {...}, "data": {...}},
  ],
  "edges": [
    {"id": "...", "source": "...", "target": "...", "sourceHandle": "success|failure", "data": {"branchType": "success|failure"}}
  ]
}
```

다음 타입들을 정의한다:

1. `FlowData` - JSON 파싱용 raw 구조체:
   - `Nodes []FlowNode`
   - `Edges []FlowEdge`

2. `FlowNode` - JSON 노드 표현:
   - `ID string`, `Type string`, `Data map[string]interface{}`

3. `FlowEdge` - JSON 엣지 표현:
   - `ID string`, `Source string`, `Target string`, `SourceHandle string`, `Data map[string]interface{}`

4. `GraphNode` - 실행 그래프 노드:
   - `ID string`, `Type string` (command|event)
   - `InstanceID string` - 소속 SIP Instance 노드 ID
   - `Command string` - MakeCall|Answer|Release (command 노드 전용)
   - `TargetURI string` - MakeCall 대상 URI (command 노드 전용)
   - `Event string` - INCOMING|DISCONNECTED|RINGING|TIMEOUT (event 노드 전용)
   - `Timeout time.Duration` - 타임아웃 (기본 10초)
   - `SuccessNext *GraphNode` - 성공 분기 다음 노드
   - `FailureNext *GraphNode` - 실패 분기 다음 노드

5. `SipInstanceConfig` - SIP Instance 설정:
   - `ID string` - 인스턴스 노드 ID
   - `Label string`
   - `Mode string` - DN|Endpoint
   - `DN string`
   - `Register bool`
   - `Color string`

6. `InstanceChain` - 인스턴스별 실행 체인:
   - `Config SipInstanceConfig`
   - `StartNodes []*GraphNode` - 인스턴스 노드에서 직접 연결된 시작 노드들

7. `ExecutionGraph` - 전체 실행 그래프:
   - `Instances map[string]*InstanceChain` - instanceID -> 체인
   - `Nodes map[string]*GraphNode` - nodeID -> 노드

모든 타입에 `json` 태그를 생략하고 내부 사용만 한다. package는 `engine`이다.
</instruction>
<verify>
`go build ./internal/engine/...` 가 에러 없이 컴파일되는지 확인한다.
</verify>
</task>

<task id="2">
<title>ParseScenario 그래프 파서 구현</title>
<instruction>
`internal/engine/graph.go` 파일에 `ParseScenario(flowData string) (*ExecutionGraph, error)` 함수를 구현한다.

변환 알고리즘:
1. `flowData` JSON 문자열을 `FlowData` 구조체로 언마샬한다.
2. 모든 `sipInstance` 타입 노드를 `SipInstanceConfig`로 변환하여 `Instances` 맵에 등록한다:
   - `data.mode`를 string으로 추출 (기본값 "DN")
   - `data.dn`을 string으로 추출
   - `data.register`를 bool로 추출 (기본값 true)
   - `data.label`을 string으로 추출
   - `data.color`를 string으로 추출
3. 모든 `command`/`event` 타입 노드를 `GraphNode`로 변환하여 `Nodes` 맵에 등록한다:
   - command 노드: `data.command` (string), `data.sipInstanceId` (string), `data.targetUri` (string, 없을 수 있음), `data.timeout` (float64 -> time.Duration 밀리초)
   - event 노드: `data.event` (string), `data.sipInstanceId` (string), `data.timeout` (float64 -> time.Duration 밀리초, 기본 10초)
   - `map[string]interface{}`에서 타입 안전하게 추출하기 위해 헬퍼 함수 `getStringField(data, key, defaultVal)`, `getBoolField(data, key, defaultVal)`, `getFloatField(data, key, defaultVal)` 사용
4. 모든 엣지를 순회하여 `SuccessNext`/`FailureNext` 포인터를 설정한다:
   - `sourceHandle`이 "failure"이거나 `data.branchType`이 "failure"이면 `FailureNext`
   - 그 외 모든 경우 `SuccessNext`
   - source가 `sipInstance` 타입인 경우: target 노드를 해당 인스턴스의 `StartNodes`에 추가
   - source가 `command`/`event` 타입인 경우: source 노드의 `SuccessNext` 또는 `FailureNext` 설정
5. 검증:
   - 인스턴스가 0개이면 에러 반환
   - command/event 노드에 `sipInstanceId`가 없으면 에러 반환
   - `sipInstanceId`가 실제 인스턴스 맵에 없으면 에러 반환

헬퍼 함수들은 같은 파일 하단에 private 함수로 정의한다:
```go
func getStringField(data map[string]interface{}, key, defaultVal string) string
func getBoolField(data map[string]interface{}, key string, defaultVal bool) bool
func getFloatField(data map[string]interface{}, key string, defaultVal float64) float64
```
</instruction>
<verify>
`go vet ./internal/engine/...` 가 경고 없이 통과하는지 확인한다.
</verify>
</task>

<task id="3">
<title>Engine 타입 골격 + EventEmitter 추상화 + 이벤트 발행 헬퍼</title>
<instruction>
1. `internal/engine/engine.go` 파일을 생성한다:

```go
package engine

import (
    "context"
    "fmt"
    "sync"

    "sipflow/internal/scenario"
)
```

`Engine` 구조체 정의:
- `ctx context.Context` - Wails runtime context
- `repo *scenario.Repository` - 시나리오 로드용
- `emitter EventEmitter` - 이벤트 발행 추상화 (events.go에서 정의)
- `mu sync.Mutex` - 동시 실행 방지
- `running bool` - 실행 중 여부
- `cancelFunc context.CancelFunc` - StopScenario 시 전체 취소
- `wg sync.WaitGroup` - 모든 인스턴스 goroutine 완료 대기

생성자: `func NewEngine(repo *scenario.Repository) *Engine`
- repo를 주입받아 저장
- emitter는 nil로 초기화 (SetContext 시 자동 설정)

`func (e *Engine) SetContext(ctx context.Context)`:
- Wails runtime context 설정
- **자동으로 `WailsEventEmitter`를 생성하여 `e.emitter`에 설정**:
  ```go
  e.ctx = ctx
  e.emitter = &WailsEventEmitter{ctx: ctx}
  ```

`func (e *Engine) SetEventEmitter(emitter EventEmitter)`:
- 테스트 등 외부에서 커스텀 EventEmitter를 주입할 수 있도록 하는 메서드
- `e.emitter = emitter`

메서드 스텁 (후속 계획에서 구현):
- `func (e *Engine) StartScenario(scenarioID string) error` - "not implemented" 반환
- `func (e *Engine) StopScenario() error` - "not implemented" 반환
- `func (e *Engine) IsRunning() bool` - `e.running` 반환

2. `internal/engine/events.go` 파일을 생성한다:

**EventEmitter 인터페이스 정의:**
```go
// EventEmitter는 이벤트 발행을 추상화한다.
// 프로덕션에서는 WailsEventEmitter, 테스트에서는 TestEventEmitter를 사용한다.
type EventEmitter interface {
    Emit(eventName string, data map[string]interface{})
}
```

**WailsEventEmitter 구현 (프로덕션용):**
```go
type WailsEventEmitter struct {
    ctx context.Context
}

func (we *WailsEventEmitter) Emit(eventName string, data map[string]interface{}) {
    if we.ctx != nil {
        runtime.EventsEmit(we.ctx, eventName, data)
    }
}
```

import에 `"github.com/wailsapp/wails/v2/pkg/runtime"` 필요.

이벤트 이름 상수:
```go
const (
    EventNodeState  = "scenario:node-state"
    EventActionLog  = "scenario:action-log"
    EventStarted    = "scenario:started"
    EventCompleted  = "scenario:completed"
    EventFailed     = "scenario:failed"
    EventStopped    = "scenario:stopped"
)
```

노드 상태 상수:
```go
const (
    NodeStatePending   = "pending"
    NodeStateRunning   = "running"
    NodeStateCompleted = "completed"
    NodeStateFailed    = "failed"
)
```

이벤트 발행 헬퍼 메서드 — **`e.emitter.Emit()` 호출로 구현:**
- `func (e *Engine) emitNodeState(nodeID, prevState, newState string)`:
  ```go
  if e.emitter != nil {
      e.emitter.Emit(EventNodeState, map[string]interface{}{
          "nodeId": nodeID, "previousState": prevState,
          "newState": newState, "timestamp": time.Now().UnixMilli(),
      })
  }
  ```
- `func (e *Engine) emitActionLog(nodeID, instanceID, message, level string)` - level은 "info"|"warning"|"error", 동일 패턴으로 `e.emitter.Emit()` 호출
- `func (e *Engine) emitScenarioStarted(scenarioID string)` - `e.emitter.Emit(EventStarted, ...)` 호출
- `func (e *Engine) emitScenarioCompleted()` - `e.emitter.Emit(EventCompleted, ...)` 호출
- `func (e *Engine) emitScenarioFailed(errMsg string)` - `e.emitter.Emit(EventFailed, ...)` 호출
- `func (e *Engine) emitScenarioStopped()` - `e.emitter.Emit(EventStopped, ...)` 호출

모든 이벤트에 `timestamp` 필드를 `time.Now().UnixMilli()`로 포함한다.
모든 헬퍼에서 `e.emitter`가 nil인 경우 안전하게 skip한다 (nil guard).
</instruction>
<verify>
`go build ./internal/engine/...` 가 에러 없이 컴파일되는지 확인한다. `internal/engine/` 디렉토리에 `engine.go`, `events.go`, `graph.go` 3개 파일이 존재하는지 확인한다.
</verify>
</task>

<task id="4">
<title>ParseScenario 단위 테스트</title>
<instruction>
`internal/engine/graph_test.go` 파일을 생성한다.

다음 테스트 케이스를 구현한다:

1. `TestParseScenario_BasicTwoInstance` - 2개 인스턴스, MakeCall + Incoming + Answer 시나리오:
   - JSON 입력:
     - sipInstance A (id: "inst-a", dn: "100")
     - sipInstance B (id: "inst-b", dn: "200")
     - command MakeCall (id: "cmd-1", sipInstanceId: "inst-a", targetUri: "sip:200@127.0.0.1:5062")
     - event INCOMING (id: "evt-1", sipInstanceId: "inst-b")
     - command Answer (id: "cmd-2", sipInstanceId: "inst-b")
     - 엣지: inst-a -> cmd-1 (success), inst-b -> evt-1 (success), evt-1 -> cmd-2 (success)
   - 검증:
     - 인스턴스 2개 파싱됨
     - inst-a의 StartNodes에 cmd-1 포함
     - inst-b의 StartNodes에 evt-1 포함
     - cmd-1의 SuccessNext 없음 (다음 노드 연결 안 됨)
     - evt-1의 SuccessNext == cmd-2
     - evt-1의 Timeout == 10초 (기본값)

2. `TestParseScenario_FailureBranch` - failure 분기 테스트:
   - command MakeCall에 success와 failure 분기 모두 연결
   - 검증: SuccessNext와 FailureNext 모두 설정됨

3. `TestParseScenario_CustomTimeout` - 커스텀 타임아웃:
   - event INCOMING에 timeout: 5000 (5초) 설정
   - 검증: Timeout == 5 * time.Second

4. `TestParseScenario_EmptyFlowData` - 빈 JSON:
   - `{}` 입력
   - 검증: 에러 반환 (인스턴스 0개)

5. `TestParseScenario_MissingInstanceId` - sipInstanceId 누락:
   - command 노드에 sipInstanceId 없음
   - 검증: 에러 반환

테스트 JSON은 `json.Marshal`이 아닌 raw string literal로 작성하여 프론트엔드 출력과 동일한 형태를 유지한다.
</instruction>
<verify>
`go test ./internal/engine/... -v` 가 모든 테스트를 통과하는지 확인한다.
</verify>
</task>

## 검증 기준
- [ ] `go build ./internal/engine/...` 성공
- [ ] `go vet ./internal/engine/...` 경고 없음
- [ ] `go test ./internal/engine/... -v` 5개 테스트 모두 통과
- [ ] `ExecutionGraph`, `GraphNode`, `InstanceChain` 타입 정의됨
- [ ] `ParseScenario` 함수가 프론트엔드 JSON을 올바르게 파싱
- [ ] Engine 타입 골격과 이벤트 상수/헬퍼 정의됨
- [ ] `.gitkeep` 파일 삭제됨

## must_haves
- 프론트엔드 FlowData JSON을 Go ExecutionGraph로 변환하는 파서
- 인스턴스별 노드 체인(StartNodes + SuccessNext/FailureNext) 구축
- Event 노드 기본 타임아웃 10초 적용
- Engine 타입 골격 (StartScenario/StopScenario 스텁)
- EventEmitter 인터페이스 + WailsEventEmitter 프로덕션 구현
- SetContext 시 WailsEventEmitter 자동 설정, SetEventEmitter로 테스트용 주입 가능
- Wails 이벤트 이름 상수 및 발행 헬퍼 (emitter.Emit 호출)
