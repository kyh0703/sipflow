---
plan: "03-02"
title: "인스턴스 매니저 + 로컬 모드 포트 할당"
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/engine/instance_manager.go
  - internal/engine/instance_manager_test.go
autonomous: true
estimated_tasks: 3
---

# Plan 03-02: 인스턴스 매니저 + 로컬 모드 포트 할당

## 목표
diago SIP UA 인스턴스를 생성하고 관리하는 InstanceManager를 구현한다. 로컬 모드에서 127.0.0.1에 바인딩하여 UA 간 실제 SIP 통신이 가능하도록 포트 순차 할당, 충돌 재시도 로직을 구현한다.

## 컨텍스트
CONTEXT.md 결정사항에 따라 Phase 03은 로컬 모드만 구현한다. 각 SIP Instance 노드에 대응하는 diago UA를 127.0.0.1에 바인딩하고, 포트는 5060부터 +2 간격으로 순차 할당한다. 포트 충돌 시 자동으로 다음 포트를 시도한다.

diago API (03-RESEARCH.md 참조):
- `sipgo.NewUA()` - UserAgent 생성
- `diago.NewDiago(ua, diago.WithTransport(...))` - Diago 인스턴스 생성
- `dg.Serve(ctx, handler)` / `dg.ServeBackground(ctx, handler)` - 서버 시작

Plan 03-01에서 정의한 `ExecutionGraph.Instances` 맵의 각 `InstanceChain`에 UA와 포트를 할당한다.

## 태스크

<task id="1">
<title>InstanceManager 타입 및 UA 생성 로직</title>
<instruction>
`internal/engine/instance_manager.go` 파일을 생성한다.

```go
package engine

import (
    "context"
    "fmt"
    "net"
    "sync"

    "github.com/emiago/diago"
    "github.com/emiago/sipgo"
)
```

1. `ManagedInstance` 구조체 정의:
   - `Config SipInstanceConfig` - 인스턴스 설정 (graph.go에서 정의)
   - `UA *diago.Diago` - diago 인스턴스
   - `Port int` - 바인딩된 포트
   - `incomingCh chan *diago.DialogServerSession` - Incoming 이벤트 전달용 채널 (버퍼 1)
   - `cancel context.CancelFunc` - Serve 취소용

2. `InstanceManager` 구조체 정의:
   - `mu sync.Mutex`
   - `instances map[string]*ManagedInstance` - instanceID -> ManagedInstance
   - `basePort int` - 시작 포트 (기본 5060)
   - `nextPort int` - 다음 할당할 포트
   - `maxRetries int` - 포트 충돌 시 최대 재시도 횟수 (기본 10)

3. 생성자: `func NewInstanceManager() *InstanceManager`
   - basePort: 5060, nextPort: 5060, maxRetries: 10

4. `func (im *InstanceManager) CreateInstances(graph *ExecutionGraph) error`:
   - `graph.Instances` 맵을 순회한다
   - 각 인스턴스에 대해:
     a. 사용 가능한 포트를 찾는다 (`im.allocatePort()`)
     b. `sipgo.NewUA()` 호출
     c. `diago.NewDiago(ua, diago.WithTransport(diago.Transport{Transport: "udp", BindHost: "127.0.0.1", BindPort: port}))` 호출
     d. `ManagedInstance` 생성하여 `im.instances` 맵에 저장
     e. `incomingCh`는 `make(chan *diago.DialogServerSession, 1)`로 생성
   - 하나라도 실패하면 이미 생성된 모든 UA를 정리(Close)하고 에러 반환

5. `func (im *InstanceManager) allocatePort() (int, error)`:
   - `im.nextPort`부터 시작하여 포트 사용 가능 여부 확인
   - 사용 가능 여부: `net.ListenPacket("udp", fmt.Sprintf("127.0.0.1:%d", port))`로 테스트 후 즉시 닫기
   - 사용 가능하면 `im.nextPort = port + 2` 업데이트 후 반환
   - 충돌 시 +2하여 재시도, `im.maxRetries` 초과 시 에러 반환

6. `func (im *InstanceManager) StartServing(ctx context.Context) error`:
   - 모든 인스턴스에 대해 **별도 goroutine으로 `dg.Serve(ctx, handler)` 호출**:
     ```go
     for _, inst := range im.instances {
         instCtx, instCancel := context.WithCancel(ctx)
         inst.cancel = instCancel
         go func(i *ManagedInstance, c context.Context) {
             _ = i.UA.Serve(c, func(inDialog *diago.DialogServerSession) {
                 i.incomingCh <- inDialog
             })
         }(inst, instCtx)
     }
     ```
   - handler: `func(inDialog *diago.DialogServerSession)` - `instance.incomingCh <- inDialog` 로 채널에 전달
   - 각 인스턴스에 대해 별도 cancelable context 생성하여 `instance.cancel`에 저장
   - Serve는 blocking이므로 반드시 goroutine 안에서 호출해야 함

7. `func (im *InstanceManager) GetInstance(instanceID string) (*ManagedInstance, error)`:
   - instanceID로 ManagedInstance 조회, 없으면 에러

8. `func (im *InstanceManager) Cleanup() error`:
   - 모든 인스턴스의 cancel() 호출 (Serve 중지)
   - 모든 UA의 Close() 호출
   - instances 맵 초기화
   - nextPort를 basePort로 리셋

9. `func (im *InstanceManager) Reset()`:
   - Cleanup 호출 후 내부 상태 초기화
</instruction>
<verify>
`go build ./internal/engine/...` 가 에러 없이 컴파일되는지 확인한다.
</verify>
</task>

<task id="2">
<title>InstanceManager를 Engine에 연결</title>
<instruction>
`internal/engine/engine.go`를 수정하여 InstanceManager를 Engine에 통합한다.

1. Engine 구조체에 필드 추가:
   - `im *InstanceManager`

2. `NewEngine` 생성자에서 `im: NewInstanceManager()` 초기화

3. Engine에 편의 메서드 추가:
   - `func (e *Engine) GetInstanceManager() *InstanceManager` - im 반환
</instruction>
<verify>
`go build ./internal/engine/...` 가 에러 없이 컴파일되는지 확인한다.
</verify>
</task>

<task id="3">
<title>포트 할당 단위 테스트</title>
<instruction>
`internal/engine/instance_manager_test.go` 파일을 생성한다.

다음 테스트 케이스를 구현한다:

1. `TestAllocatePort_Sequential` - 순차 포트 할당:
   - InstanceManager 생성 후 allocatePort를 3회 호출
   - 검증: 5060, 5062, 5064 순서로 반환됨
   - 참고: allocatePort는 private이므로 `CreateInstances`를 통해 간접 테스트하거나, 테스트용으로 같은 패키지에서 직접 호출

2. `TestCreateInstances_Basic` - 기본 인스턴스 생성:
   - 2개 인스턴스를 가진 ExecutionGraph 생성 (ParseScenario 사용 또는 직접 구성)
   - `CreateInstances` 호출
   - 검증: 2개 ManagedInstance 생성됨, 각각 다른 포트
   - 검증 후 `Cleanup()` 호출

3. `TestCleanup` - 정리 동작:
   - 인스턴스 생성 후 Cleanup 호출
   - 검증: instances 맵이 비어있음

참고: diago UA 생성은 실제 네트워크 소켓을 사용하므로, 테스트 환경에서 포트가 사용 가능한지 확인해야 한다. 필요 시 `basePort`를 높은 번호(예: 15060)로 설정하여 충돌을 피한다.
</instruction>
<verify>
`go test ./internal/engine/... -v -run TestAllocatePort` 및 `go test ./internal/engine/... -v -run TestCreateInstances` 통과 확인.
</verify>
</task>

## 검증 기준
- [ ] `go build ./internal/engine/...` 성공
- [ ] InstanceManager가 ExecutionGraph의 인스턴스별로 diago UA를 생성
- [ ] 포트가 5060부터 +2 간격으로 순차 할당됨
- [ ] 포트 충돌 시 자동 재시도 동작
- [ ] Cleanup이 모든 UA와 리소스를 정리
- [ ] incomingCh 채널이 각 인스턴스에 생성됨
- [ ] 단위 테스트 통과

## must_haves
- diago UA 인스턴스를 127.0.0.1에 바인딩하여 생성하는 InstanceManager
- 포트 순차 할당 (5060, 5062, 5064...) 및 충돌 재시도
- Incoming 이벤트를 채널로 전달하는 메커니즘
- 모든 UA 리소스를 정리하는 Cleanup
