---
plan: "03-05"
title: "프론트엔드 실행 기초 — ExecutionStore + 타입 + API 훅"
wave: 4
depends_on: ["03-01", "03-04"]
files_modified:
  - frontend/src/features/scenario-builder/store/execution-store.ts
  - frontend/src/features/scenario-builder/types/execution.ts
  - frontend/src/features/scenario-builder/hooks/use-engine-api.ts
autonomous: true
estimated_tasks: 3
---

# Plan 03-05: 프론트엔드 실행 기초 — ExecutionStore + 타입 + API 훅

## 목표
프론트엔드에서 시나리오 실행 상태를 관리하기 위한 기초 인프라를 구축한다. 실행 관련 TypeScript 타입, Zustand ExecutionStore, 백엔드 호출 훅(use-engine-api)을 생성한다.

## 컨텍스트
CONTEXT.md 결정사항:
- Wails runtime.EventsEmit -> EventsOn 이벤트 스트림
- 이벤트: 노드 상태 변경, 액션 로그, 시나리오 상태
- 제어 API: StartScenario + StopScenario
- 상태 조회: 이벤트 스트림만 (폴링 없음)
- 실행 이력: 메모리만
- 추상화된 이벤트만 표시

Wails runtime API (frontend/wailsjs/runtime/runtime.d.ts):
- `EventsOn(eventName: string, callback: (...data: any) => void): () => void`
- `EventsOff(eventName: string, ...additionalEventNames: string[]): void`

기존 패턴 (use-scenario-api.ts):
- `import { StartScenario } from '../../../../wailsjs/go/binding/EngineBinding'` 형태로 import
- 프론트엔드 파일명: kebab-case
- Wails models.ts namespace import 패턴

**의존성**: 이 계획은 Plan 03-04에서 추가한 `StartScenario`, `StopScenario`, `IsRunning` Go 메서드에 대해 Wails가 자동 생성하는 TypeScript 바인딩(`frontend/wailsjs/go/binding/EngineBinding.js/d.ts`)을 사용한다. 따라서 03-04 완료 후 `wails generate module` 실행이 선행되어야 한다.

## 태스크

<task id="1">
<title>실행 관련 TypeScript 타입 정의</title>
<instruction>
`frontend/src/features/scenario-builder/types/execution.ts` 파일을 새로 생성한다.

```typescript
// 노드 실행 상태
export type NodeExecutionStatus = 'pending' | 'running' | 'completed' | 'failed';

// 시나리오 실행 상태
export type ScenarioExecutionStatus = 'idle' | 'running' | 'completed' | 'failed' | 'stopped';

// Wails 이벤트 이름 상수
export const EXECUTION_EVENTS = {
  NODE_STATE: 'scenario:node-state',
  ACTION_LOG: 'scenario:action-log',
  STARTED: 'scenario:started',
  COMPLETED: 'scenario:completed',
  FAILED: 'scenario:failed',
  STOPPED: 'scenario:stopped',
} as const;

// Go -> Frontend 이벤트 페이로드 타입
export interface NodeStateEvent {
  nodeId: string;
  previousState: NodeExecutionStatus;
  newState: NodeExecutionStatus;
  timestamp: number;
}

export interface ActionLogEvent {
  timestamp: number;
  nodeId: string;
  instanceId: string;
  message: string;
  level: 'info' | 'warning' | 'error';
}

export interface ScenarioStartedEvent {
  scenarioId: string;
  timestamp: number;
}

export interface ScenarioCompletedEvent {
  timestamp: number;
}

export interface ScenarioFailedEvent {
  timestamp: number;
  error: string;
}

export interface ScenarioStoppedEvent {
  timestamp: number;
}

// Store에서 사용하는 노드 상태
export interface NodeExecutionState {
  nodeId: string;
  status: NodeExecutionStatus;
  startedAt?: number;
  completedAt?: number;
}

// Store에서 사용하는 액션 로그
export interface ActionLog {
  id: string;  // 고유 ID (timestamp + index)
  timestamp: number;
  nodeId: string;
  instanceId: string;
  message: string;
  level: 'info' | 'warning' | 'error';
}
```
</instruction>
<verify>
`cd frontend && npx tsc --noEmit` 타입 에러 없음 확인.
</verify>
</task>

<task id="2">
<title>ExecutionStore (Zustand) 생성</title>
<instruction>
`frontend/src/features/scenario-builder/store/execution-store.ts` 파일을 새로 생성한다.

```typescript
import { create } from 'zustand';
import { EventsOn, EventsOff } from '../../../../wailsjs/runtime/runtime';
import type {
  ScenarioExecutionStatus,
  NodeExecutionState,
  ActionLog,
  NodeStateEvent,
  ActionLogEvent,
  ScenarioStartedEvent,
  ScenarioFailedEvent,
} from '../types/execution';
import { EXECUTION_EVENTS } from '../types/execution';
```

실제 import 경로 계산:
- execution-store.ts 위치: `frontend/src/features/scenario-builder/store/`
- runtime.js 위치: `frontend/wailsjs/runtime/`
- 상대 경로: `../../../../wailsjs/runtime/runtime`

Store 인터페이스:
```typescript
interface ExecutionState {
  status: ScenarioExecutionStatus;
  nodeStates: Record<string, NodeExecutionState>;  // nodeId -> state
  actionLogs: ActionLog[];
  scenarioError: string | null;

  // 이벤트 리스너 관리
  startListening: () => void;
  stopListening: () => void;

  // 상태 업데이트
  updateNodeState: (event: NodeStateEvent) => void;
  addActionLog: (event: ActionLogEvent) => void;

  // 리셋
  reset: () => void;

  // 유틸리티
  getNodeStatus: (nodeId: string) => NodeExecutionState | undefined;
  isRunning: () => boolean;
}
```

구현:
- `startListening()`: 6개 이벤트에 대해 `EventsOn` 등록
  - `scenario:node-state` -> `updateNodeState`
  - `scenario:action-log` -> `addActionLog`
  - `scenario:started` -> `set({ status: 'running', scenarioError: null })`
  - `scenario:completed` -> `set({ status: 'completed' })`
  - `scenario:failed` -> `set({ status: 'failed', scenarioError: event.error })`
  - `scenario:stopped` -> `set({ status: 'stopped' })`
- `stopListening()`: `EventsOff`로 모든 이벤트 해제
- `updateNodeState(event)`: `nodeStates` Record에 추가/업데이트 (immutable)
- `addActionLog(event)`: `actionLogs` 배열에 추가, 최대 500개 유지 (오래된 것 삭제)
- `reset()`: 모든 상태 초기화 (status: 'idle', nodeStates: {}, actionLogs: [], scenarioError: null)
- `getNodeStatus(nodeId)`: `nodeStates[nodeId]` 반환
- `isRunning()`: `status === 'running'`

중요: `Record<string, NodeExecutionState>`를 사용하여 Map 대신 plain object로 관리한다 (Zustand의 immutable 업데이트 용이).
</instruction>
<verify>
`cd frontend && npx tsc --noEmit` 타입 에러 없음 확인.
</verify>
</task>

<task id="3">
<title>use-engine-api 훅 생성</title>
<instruction>
`frontend/src/features/scenario-builder/hooks/use-engine-api.ts` 파일을 새로 생성한다.

기존 `use-scenario-api.ts` 패턴을 따른다.

```typescript
import {
  StartScenario,
  StopScenario,
  IsRunning,
} from '../../../../wailsjs/go/binding/EngineBinding';
```

**전제 조건**: 이 import가 동작하려면 Plan 03-04 완료 후 Wails 바인딩이 재생성되어야 한다. 구현 시 `wails generate module` 또는 `wails dev`를 먼저 실행하여 `frontend/wailsjs/go/binding/EngineBinding.js`와 `EngineBinding.d.ts`가 생성되었는지 확인한다.

```typescript
export function useEngineApi() {
  const startScenario = async (scenarioId: string): Promise<void> => {
    try {
      await StartScenario(scenarioId);
    } catch (error) {
      console.error('Failed to start scenario:', error);
      throw error;
    }
  };

  const stopScenario = async (): Promise<void> => {
    try {
      await StopScenario();
    } catch (error) {
      console.error('Failed to stop scenario:', error);
      throw error;
    }
  };

  const isRunning = async (): Promise<boolean> => {
    try {
      return await IsRunning();
    } catch (error) {
      console.error('Failed to check running status:', error);
      return false;
    }
  };

  return {
    startScenario,
    stopScenario,
    isRunning,
  };
}
```
</instruction>
<verify>
`cd frontend && npx tsc --noEmit` 타입 에러 없음 확인. (Note: 반드시 03-04 완료 후 `wails generate module` 실행하여 Wails 바인딩 생성 필요)
</verify>
</task>

## 검증 기준
- [ ] `cd frontend && npx tsc --noEmit` 성공
- [ ] ExecutionStore가 Wails 이벤트를 수신하여 상태 업데이트
- [ ] use-engine-api 훅이 StartScenario/StopScenario/IsRunning 호출 가능
- [ ] Wails 바인딩 재생성 후 EngineBinding import 정상 동작

## must_haves
- Wails EventsOn/EventsOff를 사용한 실시간 이벤트 수신
- ExecutionStore (Zustand)로 실행 상태 관리
- use-engine-api 훅으로 백엔드 제어 API 호출
- 실행 관련 TypeScript 타입 정의
