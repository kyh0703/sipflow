---
plan: "03-04"
title: "Engine 오케스트레이션 + Wails 바인딩"
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - internal/engine/engine.go
  - internal/binding/engine_binding.go
  - app.go
autonomous: true
estimated_tasks: 4
---

# Plan 03-04: Engine 오케스트레이션 + Wails 바인딩

## 목표
Engine의 `StartScenario`/`StopScenario` 전체 실행 오케스트레이션을 구현하고, EngineBinding을 통해 프론트엔드에서 호출할 수 있도록 Wails 바인딩을 연결한다.

## 컨텍스트
Plan 03-01에서 그래프 파서, 03-02에서 인스턴스 매니저, 03-03에서 실행기를 구현했다. 이 계획에서는 이 모든 컴포넌트를 Engine에서 오케스트레이션하여 시나리오 실행의 전체 흐름을 완성한다.

CONTEXT.md 결정사항:
- 제어 API: StartScenario + StopScenario만 (Pause/Resume 없음)
- 시나리오 완료: 모든 인스턴스의 마지막 노드 실행 완료 + 모든 SIP 세션 cleanup
- 이벤트 스트림: Wails runtime.EventsEmit으로 Go -> Frontend 실시간 발행
- 실행 이력: 메모리만 (Phase 03)

현재 `app.go`에서 `EngineBinding`은 `binding.NewEngineBinding()`으로 생성되며, `main.go`의 `Bind` 슬라이스에 등록되어 있다. 현재 `EngineBinding`에는 `Ping()`과 `GetVersion()`만 존재한다.

## 태스크

<task id="1">
<title>Engine.StartScenario 전체 오케스트레이션 구현</title>
<instruction>
`internal/engine/engine.go`의 `StartScenario` 스텁을 실제 구현으로 교체한다.

`func (e *Engine) StartScenario(scenarioID string) error`:

1. 동시 실행 방지:
   ```go
   e.mu.Lock()
   if e.running {
       e.mu.Unlock()
       return fmt.Errorf("scenario already running")
   }
   e.running = true
   e.mu.Unlock()
   ```

2. 시나리오 로드: `e.repo.LoadScenario(scenarioID)`
   - 실패 시 `e.running = false` 후 에러 반환

3. 그래프 파싱: `ParseScenario(scenario.FlowData)`
   - 실패 시 cleanup 후 에러 반환

4. 인스턴스 생성: `e.im.CreateInstances(graph)`
   - 실패 시 cleanup 후 에러 반환

5. 인스턴스 Serve 시작: `e.im.StartServing(ctx)` (ctx는 아래에서 생성)
   - 실패 시 cleanup 후 에러 반환

6. 실행 context 생성:
   ```go
   execCtx, cancel := context.WithCancel(context.Background())
   e.cancelFunc = cancel
   ```

7. 시나리오 시작 이벤트 발행: `e.emitScenarioStarted(scenarioID)`

8. Executor 생성: `executor := NewExecutor(e, e.im)`

9. 각 인스턴스마다 goroutine 실행:
   ```go
   errCh := make(chan error, len(graph.Instances))

   for instanceID, chain := range graph.Instances {
       e.wg.Add(1)
       go func(id string, ch *InstanceChain) {
           defer e.wg.Done()
           for _, startNode := range ch.StartNodes {
               if err := executor.ExecuteChain(execCtx, id, startNode); err != nil {
                   errCh <- fmt.Errorf("instance %s: %w", id, err)
                   cancel() // 전체 중단
                   return
               }
           }
       }(instanceID, chain)
   }
   ```

10. 별도 goroutine에서 완료 대기 및 최종 처리:
    ```go
    go func() {
        e.wg.Wait()
        // cleanup
        e.cleanup(executor)

        // 결과 판단
        select {
        case err := <-errCh:
            e.emitScenarioFailed(err.Error())
        default:
            e.emitScenarioCompleted()
        }

        e.mu.Lock()
        e.running = false
        e.cancelFunc = nil
        e.mu.Unlock()
    }()
    ```

11. StartScenario는 goroutine 시작 후 즉시 nil 반환 (비동기 실행)

에러 발생 시 정리하는 private 헬퍼:
```go
func (e *Engine) cleanupOnError() {
    e.im.Cleanup()
    e.mu.Lock()
    e.running = false
    e.mu.Unlock()
}
```
</instruction>
<verify>
`go build ./internal/engine/...` 및 `go build ./...` 가 에러 없이 컴파일되는지 확인한다.
</verify>
</task>

<task id="2">
<title>Engine.StopScenario 및 cleanup 구현</title>
<instruction>
`internal/engine/engine.go`의 `StopScenario` 스텁을 실제 구현으로 교체한다.

`func (e *Engine) StopScenario() error`:
1. 실행 중이 아니면 에러: "no running scenario"
2. `e.cancelFunc()` 호출 — 모든 goroutine의 context 취소
3. 타임아웃으로 goroutine 종료 대기 (최대 10초):
   ```go
   done := make(chan struct{})
   go func() {
       e.wg.Wait()
       close(done)
   }()

   select {
   case <-done:
       // 정상 종료
   case <-time.After(10 * time.Second):
       // 강제 종료 (로그 경고)
   }
   ```
4. 이벤트 발행: `e.emitScenarioStopped()`
5. 상태 리셋

`func (e *Engine) cleanup(executor *Executor)` private 메서드:
1. 액션 로그 발행: "Starting cleanup"
2. `executor.sessions.HangupAll(ctx)` - 5초 타임아웃으로 모든 활성 세션 Hangup
3. `executor.sessions.CloseAll()` - 모든 세션 Close
4. `e.im.Cleanup()` - 모든 UA 정리
5. 액션 로그 발행: "Cleanup completed"
</instruction>
<verify>
`go build ./internal/engine/...` 가 에러 없이 컴파일되는지 확인한다.
</verify>
</task>

<task id="3">
<title>EngineBinding에 StartScenario/StopScenario 추가</title>
<instruction>
`internal/binding/engine_binding.go`를 수정하여 Engine과 연결한다.

1. import 추가: `"sipflow/internal/engine"`

2. EngineBinding 구조체에 필드 추가:
   - `engine *engine.Engine`

3. 생성자 변경: `func NewEngineBinding(eng *engine.Engine) *EngineBinding`
   - engine을 주입받아 저장

4. 새 메서드 추가:

   `func (e *EngineBinding) StartScenario(scenarioID string) error`:
   - `runtime.LogInfo(e.ctx, fmt.Sprintf("Starting scenario: %s", scenarioID))`
   - `e.engine.StartScenario(scenarioID)` 호출
   - 에러 시 `runtime.LogError` 후 반환

   `func (e *EngineBinding) StopScenario() error`:
   - `runtime.LogInfo(e.ctx, "Stopping scenario")`
   - `e.engine.StopScenario()` 호출
   - 에러 시 `runtime.LogError` 후 반환

   `func (e *EngineBinding) IsRunning() bool`:
   - `e.engine.IsRunning()` 반환

5. 기존 `Ping()`, `GetVersion()` 메서드는 유지한다.
</instruction>
<verify>
`go build ./internal/binding/...` 가 에러 없이 컴파일되는지 확인한다.
</verify>
</task>

<task id="4">
<title>app.go에서 Engine 초기화 및 연결</title>
<instruction>
`app.go`를 수정하여 Engine을 초기화하고 EngineBinding에 연결한다.

1. import 추가: `"sipflow/internal/engine"`

2. App 구조체에 필드 추가:
   - `engine *engine.Engine`

3. `NewApp()` 함수 수정:
   - Engine 생성: `eng := engine.NewEngine(repo)`
   - EngineBinding 생성 변경: `binding.NewEngineBinding(eng)`
   - App 구조체에 engine 필드 설정

4. `startup(ctx)` 함수 수정:
   - Engine에 context 설정: `a.engine.SetContext(ctx)`

5. `shutdown(ctx)` 함수 수정:
   - 실행 중인 시나리오 정리:
     ```go
     if a.engine != nil && a.engine.IsRunning() {
         a.engine.StopScenario()
     }
     ```
   - 기존 `a.scenarioRepo.Close()` 유지

현재 `NewApp()` 코드:
```go
return &App{
    engineBinding:   binding.NewEngineBinding(),
    scenarioBinding: binding.NewScenarioBinding(repo),
    scenarioRepo:    repo,
}
```

변경 후:
```go
eng := engine.NewEngine(repo)
return &App{
    engine:          eng,
    engineBinding:   binding.NewEngineBinding(eng),
    scenarioBinding: binding.NewScenarioBinding(repo),
    scenarioRepo:    repo,
}
```
</instruction>
<verify>
`go build ./...` 가 프로젝트 전체 컴파일에 성공하는지 확인한다. `wails dev` 실행 시 에러 없이 시작되는지 확인한다.
</verify>
</task>

## 검증 기준
- [ ] `go build ./...` 프로젝트 전체 컴파일 성공
- [ ] Engine.StartScenario가 시나리오를 로드하고 인스턴스별 goroutine으로 실행
- [ ] Engine.StopScenario가 모든 goroutine을 취소하고 리소스 정리
- [ ] 동시 실행 방지 (이미 실행 중이면 에러)
- [ ] EngineBinding.StartScenario/StopScenario가 프론트엔드에서 호출 가능
- [ ] app.go에서 Engine이 올바르게 초기화되고 context 설정됨
- [ ] 앱 종료 시 실행 중인 시나리오 자동 정리

## must_haves
- StartScenario 전체 오케스트레이션 (로드 -> 파싱 -> UA 생성 -> 실행)
- StopScenario 강제 중단 + cleanup
- EngineBinding을 통한 프론트엔드 바인딩
- app.go에서 Engine 초기화 및 lifecycle 관리
- 동시 실행 방지 (mutex)
