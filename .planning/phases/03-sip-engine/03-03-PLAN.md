---
plan: "03-03"
title: "Command 실행기 + Event 리스너"
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/engine/executor.go
  - internal/engine/executor_test.go
autonomous: true
estimated_tasks: 4
---

# Plan 03-03: Command 실행기 + Event 리스너

## 목표
시나리오 그래프의 각 노드를 실행하는 Executor를 구현한다. Command 노드(MakeCall, Answer, Release)에 대응하는 diago API 호출과, Event 노드(INCOMING, DISCONNECTED, RINGING)에 대응하는 이벤트 대기 로직을 구현한다.

## 컨텍스트
CONTEXT.md 결정사항:
- 각 SIP Instance가 자신의 노드 체인을 독립 goroutine으로 실행
- Command 실패 시 failure 분기 연결되어 있으면 failure 경로, 없으면 전체 시나리오 중단
- Event 노드 기본 타임아웃 10초, 노드별 오버라이드 가능
- 타임아웃 시 failure 분기 (없으면 전체 중단)

Plan 03-01의 `GraphNode` 구조체와 Plan 03-02의 `ManagedInstance`를 사용하여 실제 SIP 명령을 실행한다.

diago API (03-RESEARCH.md 참조):
- `dg.Invite(ctx, recipient, opts)` - MakeCall
- `inDialog.Answer()` - Answer (Serve 콜백의 DialogServerSession에서)
- `dialog.Hangup(ctx)` - Release
- `dialog.Context().Done()` - DISCONNECTED 감지
- `dg.Serve(ctx, handler)` - INCOMING 감지

## 태스크

<task id="1">
<title>Executor 타입 및 세션 관리 구조</title>
<instruction>
`internal/engine/executor.go` 파일을 생성한다.

```go
package engine

import (
    "context"
    "fmt"
    "sync"
    "time"

    "github.com/emiago/diago"
    "github.com/emiago/sipgo/sip"
)
```

1. `SessionStore` 구조체 정의 - 활성 SIP 세션을 관리:
   - `mu sync.RWMutex`
   - `dialogs map[string]diago.DialogSession` - key는 인스턴스별 세션 식별자 (예: instanceID 또는 nodeID)
   - `serverSessions map[string]*diago.DialogServerSession` - incoming dialog 보관 (instanceID -> session)

   메서드:
   - `func (ss *SessionStore) StoreDialog(key string, dialog diago.DialogSession)` - mutex 보호하여 저장
   - `func (ss *SessionStore) GetDialog(key string) (diago.DialogSession, bool)` - mutex 보호하여 조회
   - `func (ss *SessionStore) StoreServerSession(instanceID string, session *diago.DialogServerSession)` - incoming session 저장
   - `func (ss *SessionStore) GetServerSession(instanceID string) (*diago.DialogServerSession, bool)` - incoming session 조회
   - `func (ss *SessionStore) HangupAll(ctx context.Context)` - 모든 활성 dialog의 Hangup 호출 (5초 타임아웃)
   - `func (ss *SessionStore) CloseAll()` - 모든 dialog의 Close 호출

2. `Executor` 구조체 정의:
   - `engine *Engine` - 이벤트 발행용 부모 참조
   - `im *InstanceManager` - UA 조회용
   - `sessions *SessionStore` - 활성 세션 저장소

3. 생성자: `func NewExecutor(engine *Engine, im *InstanceManager) *Executor`
   - sessions를 빈 맵으로 초기화
</instruction>
<verify>
`go build ./internal/engine/...` 가 에러 없이 컴파일되는지 확인한다.
</verify>
</task>

<task id="2">
<title>노드 실행 로직 — executeNode 및 executeChain</title>
<instruction>
`internal/engine/executor.go`에 노드 실행 메서드를 추가한다.

1. `func (ex *Executor) ExecuteChain(ctx context.Context, instanceID string, startNode *GraphNode) error`:
   - 시작 노드부터 체인을 따라 순차 실행
   - 현재 노드를 `executeNode`로 실행
   - 성공 시: `node.SuccessNext`가 있으면 재귀/루프로 다음 노드 실행
   - 실패 시: `node.FailureNext`가 있으면 failure 노드부터 계속 실행
   - failure 분기도 없으면: 에러 반환 (호출자가 전체 중단 처리)
   - 매 노드 실행 전 `ctx.Done()` 체크하여 취소 감지

2. `func (ex *Executor) executeNode(ctx context.Context, instanceID string, node *GraphNode) error`:
   - 노드 상태를 "running"으로 변경 이벤트 발행: `ex.engine.emitNodeState(node.ID, NodeStatePending, NodeStateRunning)`
   - `node.Type`에 따라 분기:
     - "command": `ex.executeCommand(ctx, instanceID, node)` 호출
     - "event": `ex.executeEvent(ctx, instanceID, node)` 호출
   - 성공 시: "completed" 이벤트 발행
   - 실패 시: "failed" 이벤트 발행, 에러 반환
</instruction>
<verify>
`go build ./internal/engine/...` 가 에러 없이 컴파일되는지 확인한다.
</verify>
</task>

<task id="3">
<title>Command 실행 구현 — MakeCall, Answer, Release</title>
<instruction>
`internal/engine/executor.go`에 Command 실행 메서드를 추가한다.

`func (ex *Executor) executeCommand(ctx context.Context, instanceID string, node *GraphNode) error`:

switch문으로 `node.Command` 분기:

**MakeCall:**
1. 액션 로그 발행: "MakeCall to {targetUri}"
2. `node.TargetURI`를 파싱하여 `sip.Uri` 생성:
   - 먼저 기본 형식 검증: `node.TargetURI`가 빈 문자열이면 에러 반환 (`"MakeCall requires a targetUri"`)
   - `strings.HasPrefix(node.TargetURI, "sip:")` 확인, 없으면 에러 반환 (`"targetUri must start with sip: scheme"`)
   - `sip.ParseUri(node.TargetURI, &recipient)` 사용
   - 파싱 실패 시 구체적인 에러 반환: `fmt.Errorf("invalid targetUri %q: %w", node.TargetURI, err)`
3. 해당 인스턴스의 diago UA 조회: `ex.im.GetInstance(instanceID)`
4. 타임아웃 context 생성: `node.Timeout`이 0보다 크면 사용, 아니면 30초 기본값
5. `instance.UA.Invite(timeoutCtx, recipient, diago.InviteOptions{})` 호출
6. 성공 시 dialog를 SessionStore에 저장: `ex.sessions.StoreDialog(instanceID, dialog)`
7. 액션 로그 발행: "MakeCall succeeded"
8. 에러 시 에러 반환

**Answer:**
1. 액션 로그 발행: "Answer incoming call"
2. SessionStore에서 incoming server session 조회: `ex.sessions.GetServerSession(instanceID)`
3. 없으면 에러: "no incoming dialog to answer for instance {instanceID}"
4. `serverSession.Answer()` 호출
5. 성공 시 서버 세션을 일반 dialog로도 저장: `ex.sessions.StoreDialog(instanceID, serverSession)`
6. 액션 로그 발행: "Answer succeeded"
7. 에러 시 에러 반환

**Release:**
1. 액션 로그 발행: "Release call"
2. SessionStore에서 dialog 조회: `ex.sessions.GetDialog(instanceID)`
3. 없으면 경고 로그 후 nil 반환 (이미 종료된 경우)
4. 5초 타임아웃 context로 `dialog.Hangup(hangupCtx)` 호출
5. 액션 로그 발행: "Release succeeded"
6. 에러 시 에러 반환 (but non-fatal — 이미 종료된 dialog의 Hangup은 무시 가능)

알 수 없는 command일 경우 에러 반환: "unknown command: {command}"
</instruction>
<verify>
`go build ./internal/engine/...` 가 에러 없이 컴파일되는지 확인한다.
</verify>
</task>

<task id="4">
<title>Event 리스너 구현 — INCOMING, DISCONNECTED, RINGING</title>
<instruction>
`internal/engine/executor.go`에 Event 실행 메서드를 추가한다.

`func (ex *Executor) executeEvent(ctx context.Context, instanceID string, node *GraphNode) error`:

공통 로직:
1. 타임아웃 설정: `node.Timeout`이 0이면 기본 10초 사용
2. `context.WithTimeout(ctx, timeout)`으로 타임아웃 context 생성
3. 액션 로그 발행: "Waiting for {event} (timeout: {timeout})"

switch문으로 `node.Event` 분기:

**INCOMING:**
1. 해당 인스턴스의 `incomingCh` 채널에서 대기: `ex.im.GetInstance(instanceID)`
2. `select` 구문:
   - `case inDialog := <-instance.incomingCh:` - incoming dialog 수신
     - `ex.sessions.StoreServerSession(instanceID, inDialog)` 로 저장
     - 액션 로그 발행: "INCOMING event received from {inDialog.FromUser()}"
     - nil 반환
   - `case <-timeoutCtx.Done():` - 타임아웃
     - 에러 반환: "INCOMING event timeout after {timeout}"

**DISCONNECTED:**
1. SessionStore에서 활성 dialog 조회: `ex.sessions.GetDialog(instanceID)`
2. 없으면 에러: "no active dialog for DISCONNECTED event"
3. `select` 구문:
   - `case <-dialog.Context().Done():` - 통화 종료 감지
     - 액션 로그 발행: "DISCONNECTED event received"
     - nil 반환
   - `case <-timeoutCtx.Done():` - 타임아웃
     - 에러 반환: "DISCONNECTED event timeout after {timeout}"

**RINGING:**
- Phase 03에서 RINGING 이벤트는 단순화: MakeCall 성공 시 이미 180 Ringing을 거쳤으므로, RINGING 노드는 즉시 완료 처리
- 액션 로그 발행: "RINGING event (auto-completed in local mode)"
- nil 반환

**그 외 이벤트 (TIMEOUT, HELD, RETRIEVED, TRANSFERRED, NOTIFY):**
- 지원하지 않는 이벤트는 에러 반환: "event type {event} is not supported in Phase 03"
- TIMEOUT 이벤트는 특별 처리: `time.After(node.Timeout)` 후 자동 완료 (단순 딜레이로 동작)

---

`internal/engine/executor_test.go` 파일을 생성하여 기본 단위 테스트를 작성한다:

1. `TestExecuteChain_BasicSuccess` - 성공 체인 실행:
   - 2개 노드 연결 (node1 -> node2 via SuccessNext)
   - Mock 없이 구조 검증만 (실제 SIP 호출은 통합 테스트에서)

2. `TestSessionStore_StoreAndGet` - 세션 저장/조회:
   - SessionStore에 nil이 아닌 값 저장 후 조회
   - 없는 키 조회 시 false 반환 확인

참고: 실제 diago 호출이 필요한 Command/Event 테스트는 Plan 03-06 통합 테스트에서 수행한다. 여기서는 구조와 로직 흐름만 테스트한다.
</instruction>
<verify>
`go build ./internal/engine/...` 가 에러 없이 컴파일된다. `go test ./internal/engine/... -v -run TestSessionStore` 통과 확인.
</verify>
</task>

## 검증 기준
- [ ] `go build ./internal/engine/...` 성공
- [ ] MakeCall이 `dg.Invite()` 호출하고 dialog를 SessionStore에 저장
- [ ] Answer가 incoming server session의 `Answer()` 호출
- [ ] Release가 dialog의 `Hangup()` 호출
- [ ] INCOMING이 채널에서 incoming dialog 대기
- [ ] DISCONNECTED가 `dialog.Context().Done()` 대기
- [ ] 모든 이벤트에 타임아웃 적용 (기본 10초)
- [ ] ExecuteChain이 성공/실패 분기를 올바르게 따름
- [ ] SessionStore가 thread-safe하게 동작

## must_haves
- MakeCall, Answer, Release Command 실행 (diago API 호출)
- INCOMING, DISCONNECTED Event 대기 (채널/context 기반)
- Event 노드 타임아웃 (기본 10초, 노드별 오버라이드)
- 실패 시 failure 분기 따르기 + failure 없으면 에러 반환
- thread-safe SessionStore
