---
plan: "03-06"
title: "통합 검증 — E2E 시나리오 테스트"
wave: 5
depends_on: ["03-04", "03-05", "03-07"]
files_modified:
  - internal/engine/integration_test.go
autonomous: true
estimated_tasks: 5
---

# Plan 03-06: 통합 검증 — E2E 시나리오 테스트

## 목표
Phase 03의 모든 컴포넌트를 통합하여 실제 시나리오를 실행하고 검증하는 E2E 테스트를 작성한다. diago UA 간 로컬 SIP 통신이 올바르게 동작하고, 이벤트 스트림이 정상 발행되는지 확인한다.

## 컨텍스트
Plan 03-01~03-07에서 구현한 모든 컴포넌트를 통합 검증한다:
- Engine (오케스트레이션)
- Graph Parser (JSON -> ExecutionGraph)
- InstanceManager (diago UA 생성/관리)
- Executor (Command/Event 실행)
- Events (이벤트 발행)

CONTEXT.md의 테스트 시나리오:
1. 단순 시나리오 (1 인스턴스, MakeCall -> Release)
2. 2자 통화 시나리오 (2 인스턴스, Incoming -> Answer)
3. 실패 분기 테스트
4. 타임아웃 테스트
5. StopScenario 테스트

통합 테스트는 실제 diago SIP UA를 127.0.0.1에 바인딩하여 수행하므로, Wails runtime context는 mock한다 (EventsEmit 호출은 no-op 또는 채널로 캡처).

## 태스크

<task id="1">
<title>테스트 헬퍼 및 Mock EventEmitter 설정</title>
<instruction>
`internal/engine/integration_test.go` 파일을 생성한다.

```go
package engine

import (
    "context"
    "encoding/json"
    "fmt"
    "sync"
    "testing"
    "time"

    "sipflow/internal/scenario"
)
```

1. 테스트용 시나리오 Repository 설정:
   - 임시 디렉토리에 SQLite DB 생성: `t.TempDir()` 사용
   - `scenario.NewRepository(dbPath)` 호출
   - 테스트용 시나리오 생성 및 FlowData 저장

2. Plan 03-01 Task 3에서 구현된 `EventEmitter` 인터페이스와 `SetEventEmitter` 메서드를 활용한다. 테스트용 `TestEventEmitter`를 `integration_test.go`에 정의한다:

   ```go
   type TestEventEmitter struct {
       mu     sync.Mutex
       events []TestEvent
   }

   type TestEvent struct {
       Name string
       Data map[string]interface{}
   }

   func (te *TestEventEmitter) Emit(eventName string, data map[string]interface{}) {
       te.mu.Lock()
       defer te.mu.Unlock()
       te.events = append(te.events, TestEvent{Name: eventName, Data: data})
   }

   func (te *TestEventEmitter) GetEvents() []TestEvent {
       te.mu.Lock()
       defer te.mu.Unlock()
       return append([]TestEvent{}, te.events...)
   }

   func (te *TestEventEmitter) GetEventsByName(name string) []TestEvent {
       te.mu.Lock()
       defer te.mu.Unlock()
       var filtered []TestEvent
       for _, e := range te.events {
           if e.Name == name {
               filtered = append(filtered, e)
           }
       }
       return filtered
   }
   ```

   `eng.SetEventEmitter(te)`로 TestEventEmitter를 주입하여 이벤트를 캡처한다.

3. 테스트용 시나리오 JSON 빌더 헬퍼:
   ```go
   func buildTestFlowData(t *testing.T, nodes []FlowNode, edges []FlowEdge) string {
       t.Helper()
       fd := FlowData{Nodes: nodes, Edges: edges}
       b, err := json.Marshal(fd)
       if err != nil {
           t.Fatal(err)
       }
       return string(b)
   }
   ```

포트 충돌을 방지하기 위해 테스트에서 InstanceManager의 basePort를 15060 이상으로 설정:
```go
func newTestEngine(t *testing.T) (*Engine, *TestEventEmitter) {
    t.Helper()
    dbPath := filepath.Join(t.TempDir(), "test.db")
    repo, err := scenario.NewRepository(dbPath)
    if err != nil {
        t.Fatal(err)
    }
    t.Cleanup(func() { repo.Close() })

    eng := NewEngine(repo)
    eng.im.basePort = 15060
    eng.im.nextPort = 15060

    te := &TestEventEmitter{}
    eng.SetEventEmitter(te)

    return eng, te
}
```
</instruction>
<verify>
`go build ./internal/engine/...` 가 에러 없이 컴파일되는지 확인한다.
</verify>
</task>

<task id="2">
<title>E2E 테스트 1: 2자 통화 시나리오 (MakeCall -> Incoming -> Answer -> Release)</title>
<instruction>
`internal/engine/integration_test.go`에 다음 테스트를 추가한다.

`func TestIntegration_TwoPartyCall(t *testing.T)`:

시나리오 구성:
- Instance A (id: "inst-a", dn: "100"): Caller
  - MakeCall (id: "cmd-make", targetUri: "sip:200@127.0.0.1:{portB}", sipInstanceId: "inst-a")
  - (MakeCall 다음 노드는 없음 — 통화 성립 후 종료)
- Instance B (id: "inst-b", dn: "200"): Callee
  - INCOMING (id: "evt-incoming", sipInstanceId: "inst-b")
  - Answer (id: "cmd-answer", sipInstanceId: "inst-b")

엣지:
- inst-a -> cmd-make (success)
- inst-b -> evt-incoming (success)
- evt-incoming -> cmd-answer (success)

주의: MakeCall의 targetUri에 Instance B의 실제 포트를 넣어야 한다. 테스트에서는:
1. 먼저 InstanceManager의 포트 할당 순서를 예측하거나
2. 또는 테스트에서 직접 포트를 지정

권장 접근: flowData에서 targetUri를 `sip:200@127.0.0.1:15062`로 하드코딩 (Instance B는 두 번째 인스턴스이므로 15060+2=15062)

테스트 흐름:
1. `newTestEngine(t)` 호출
2. 시나리오 생성: `repo.CreateScenario("default", "test-2party")`
3. FlowData 저장: `repo.SaveScenario(id, flowData)`
4. `eng.StartScenario(scenarioId)` 호출
5. 최대 15초 대기하여 시나리오 완료/실패 확인
6. TestEventEmitter에서 이벤트 검증:
   - `scenario:started` 이벤트 1개
   - `scenario:node-state` 이벤트에 "running", "completed" 상태 포함
   - cmd-make, evt-incoming, cmd-answer 노드가 모두 "completed" 상태
   - `scenario:completed` 또는 적절한 종료 이벤트

중요: 이 테스트는 실제 SIP 소켓을 사용하므로 `t.Parallel()` 사용 금지. 테스트 간 포트 충돌을 피하기 위해 각 테스트에서 다른 basePort 사용 권장.

참고: Instance A의 MakeCall이 성공하려면 Instance B의 Serve가 먼저 시작되어야 한다. StartServing이 CreateInstances 후 즉시 호출되므로, MakeCall 시점에 B가 이미 listening 중이어야 한다. 타이밍 이슈가 있을 수 있으므로 짧은 sleep 또는 retry 로직 검토.
</instruction>
<verify>
`go test ./internal/engine/... -v -run TestIntegration_TwoPartyCall -timeout 30s` 통과 확인.
</verify>
</task>

<task id="3">
<title>E2E 테스트 2: 타임아웃 및 실패 분기</title>
<instruction>
`internal/engine/integration_test.go`에 다음 테스트를 추가한다.

`func TestIntegration_EventTimeout(t *testing.T)`:

시나리오: Instance A가 INCOMING을 대기하지만 아무도 전화하지 않음
- Instance A (id: "inst-a", dn: "100")
  - INCOMING (id: "evt-incoming", sipInstanceId: "inst-a", timeout: 2000) — 2초 타임아웃
- 엣지: inst-a -> evt-incoming (success)

예상 결과:
- 2초 후 INCOMING 타임아웃
- failure 분기가 없으므로 전체 시나리오 실패
- `scenario:failed` 이벤트 발행
- evt-incoming 노드가 "failed" 상태

테스트:
1. basePort: 16060 (포트 충돌 방지)
2. 시나리오 생성 및 실행
3. 5초 이내에 시나리오 실패 확인
4. TestEventEmitter에서 `scenario:failed` 이벤트 확인
5. evt-incoming의 최종 상태가 "failed" 확인

`func TestIntegration_FailureBranch(t *testing.T)`:

시나리오: MakeCall 실패 -> failure 분기로 이동
- Instance A (id: "inst-a", dn: "100")
  - MakeCall (id: "cmd-make", targetUri: "sip:999@127.0.0.1:19999", timeout: 3000) — 존재하지 않는 대상
  - failure -> Release (id: "cmd-release-fail", sipInstanceId: "inst-a") — failure 분기
- 엣지:
  - inst-a -> cmd-make (success)
  - cmd-make -> cmd-release-fail (failure)

예상 결과:
- MakeCall이 실패 (연결 불가 또는 타임아웃)
- failure 분기의 Release 실행 (dialog가 없으므로 skip)
- 시나리오 정상 완료 (failure 분기가 처리됨)

테스트:
1. basePort: 17060
2. 시나리오 실행
3. 10초 이내 완료 확인
4. cmd-make가 "failed" 상태, cmd-release-fail이 "completed" 상태
</instruction>
<verify>
`go test ./internal/engine/... -v -run TestIntegration_EventTimeout -timeout 15s` 및 `go test ./internal/engine/... -v -run TestIntegration_FailureBranch -timeout 20s` 통과 확인.
</verify>
</task>

<task id="4">
<title>E2E 테스트 3: StopScenario 강제 중단</title>
<instruction>
`internal/engine/integration_test.go`에 다음 테스트를 추가한다.

`func TestIntegration_StopScenario(t *testing.T)`:

시나리오: 장시간 대기하는 INCOMING 이벤트 실행 중 강제 중단
- Instance A (id: "inst-a", dn: "100")
  - INCOMING (id: "evt-incoming", sipInstanceId: "inst-a", timeout: 60000) — 60초 타임아웃 (사실상 무한 대기)
- 엣지: inst-a -> evt-incoming (success)

테스트 흐름:
1. basePort: 18060
2. 시나리오 실행
3. 1초 대기 후 `eng.StopScenario()` 호출
4. StopScenario가 에러 없이 반환되는지 확인
5. 3초 이내에 `eng.IsRunning()` == false 확인
6. TestEventEmitter에서 `scenario:stopped` 이벤트 확인
7. 리소스 정리 확인: 포트가 해제되었는지 (옵션)

`func TestIntegration_ConcurrentStartPrevention(t *testing.T)`:

시나리오: 이미 실행 중인 상태에서 StartScenario 재호출
1. basePort: 19060
2. 장시간 대기 시나리오 실행
3. 1초 대기 후 다시 StartScenario 호출
4. 두 번째 호출이 "scenario already running" 에러 반환 확인
5. StopScenario로 정리
</instruction>
<verify>
`go test ./internal/engine/... -v -run TestIntegration_StopScenario -timeout 20s` 및 `go test ./internal/engine/... -v -run TestIntegration_ConcurrentStart -timeout 20s` 통과 확인.
</verify>
</task>

<task id="5">
<title>프론트엔드 TypeScript 컴파일 검증 + 전체 빌드 확인</title>
<instruction>
전체 프로젝트의 빌드를 검증한다.

1. Go 백엔드 전체 빌드:
   ```bash
   cd /home/overthinker/Project/sipflow && go build ./...
   ```

2. Go 테스트 전체 실행:
   ```bash
   cd /home/overthinker/Project/sipflow && go test ./... -timeout 120s
   ```

3. 프론트엔드 TypeScript 컴파일:
   ```bash
   cd /home/overthinker/Project/sipflow/frontend && npx tsc --noEmit
   ```

4. Wails 바인딩 재생성 확인:
   - Go 메서드 추가 후 `wails generate module` 실행
   - `frontend/wailsjs/go/binding/EngineBinding.d.ts`에 `StartScenario`, `StopScenario`, `IsRunning` 존재 확인

5. 통합 검증 체크리스트:
   - [ ] Engine이 시나리오를 로드하고 파싱하여 실행
   - [ ] diago UA가 127.0.0.1에 바인딩되어 SIP 통신
   - [ ] 이벤트가 올바른 순서로 발행
   - [ ] StopScenario가 모든 리소스를 정리
   - [ ] 프론트엔드가 이벤트를 수신하여 UI 업데이트 (TypeScript 레벨 검증)

6. **프론트엔드 이벤트 수신 수동 검증**:
   - `wails dev`를 실행하여 개발 서버를 시작한다
   - 시나리오 빌더에서 2개 인스턴스 + MakeCall + Incoming + Answer 시나리오를 구성한다
   - Run 버튼을 클릭하여 시나리오를 실행한다
   - 다음 항목을 육안으로 확인한다:
     - [ ] ExecutionToolbar의 상태가 idle -> running -> completed/failed로 변경됨
     - [ ] 노드 컴포넌트의 테두리 색상이 실행 상태에 따라 변경됨 (running: 노란색, completed: 초록색, failed: 빨간색)
     - [ ] ExecutionLog 패널에 액션 로그가 실시간으로 추가됨
     - [ ] Stop 버튼 클릭 시 시나리오가 중단되고 상태가 "stopped"로 변경됨
   - 검증 결과를 기록한다 (pass/fail)

에러가 있으면 관련 파일을 수정하여 해결한다.
</instruction>
<verify>
`go build ./...` 성공, `go test ./... -timeout 120s` 전체 통과, `cd frontend && npx tsc --noEmit` 성공.
</verify>
</task>

## 검증 기준
- [ ] `go build ./...` 프로젝트 전체 컴파일 성공
- [ ] `go test ./... -timeout 120s` 모든 테스트 통과
- [ ] `cd frontend && npx tsc --noEmit` 성공
- [ ] 2자 통화 시나리오 E2E 테스트 통과 (Instance A MakeCall -> Instance B Incoming+Answer)
- [ ] 이벤트 타임아웃 테스트 통과
- [ ] 실패 분기 테스트 통과
- [ ] StopScenario 강제 중단 테스트 통과
- [ ] 동시 실행 방지 테스트 통과
- [ ] Wails 바인딩 자동 생성 확인
- [ ] 프론트엔드 이벤트 수신 수동 검증 완료 (노드 상태 표시, 로그 패널, 툴바 상태 변경)

## must_haves
- 2자 통화 E2E 테스트 (MakeCall + Incoming + Answer)
- 이벤트 타임아웃 + failure 분기 테스트
- StopScenario 강제 중단 테스트
- 전체 프로젝트 빌드 성공
- TestEventEmitter를 활용한 테스트 가능한 이벤트 검증
- 프론트엔드 이벤트 수신 수동 검증 (wails dev에서 UI 동작 확인)
