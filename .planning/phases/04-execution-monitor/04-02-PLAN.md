---
phase: 04-execution-monitor
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - frontend/src/features/scenario-builder/edges/branch-edge.tsx
  - frontend/src/features/scenario-builder/edges/animated-message-edge.tsx
  - frontend/src/features/scenario-builder/components/canvas.tsx
  - frontend/src/features/scenario-builder/components/execution-log.tsx
  - frontend/src/features/scenario-builder/components/execution-toolbar.tsx
autonomous: true

must_haves:
  truths:
    - "시나리오 실행 중 SIP 메시지가 엣지를 따라 이동하는 원형 애니메이션이 캔버스에 표시된다"
    - "로그 패널에 SIP 메시지 상세 정보(direction 화살표, method, responseCode)가 표시된다"
    - "alert() 대신 Sonner toast로 에러/성공 메시지가 표시된다"
  artifacts:
    - path: "frontend/src/features/scenario-builder/edges/animated-message-edge.tsx"
      provides: "SVG animateMotion 기반 엣지 메시지 애니메이션 컴포넌트"
      min_lines: 40
    - path: "frontend/src/features/scenario-builder/components/execution-log.tsx"
      provides: "SIP 메시지 상세 정보 표시, 레벨별 필터링"
      min_lines: 60
    - path: "frontend/src/features/scenario-builder/components/execution-toolbar.tsx"
      provides: "Sonner toast 기반 에러 표시"
      contains: "toast"
  key_links:
    - from: "frontend/src/features/scenario-builder/edges/animated-message-edge.tsx"
      to: "frontend/src/features/scenario-builder/store/execution-store.ts"
      via: "useExecutionStore에서 edgeAnimations 구독"
      pattern: "useExecutionStore.*edgeAnimations"
    - from: "frontend/src/features/scenario-builder/components/canvas.tsx"
      to: "frontend/src/features/scenario-builder/edges/animated-message-edge.tsx"
      via: "edgeTypes에 animated 타입 등록"
      pattern: "edgeTypes.*animated"
    - from: "frontend/src/features/scenario-builder/components/execution-log.tsx"
      to: "frontend/src/features/scenario-builder/types/execution.ts"
      via: "SIPMessageDetail 타입 사용"
      pattern: "sipMessage.*method"
---

<objective>
XYFlow 캔버스에서 실시간 메시지 애니메이션과 향상된 로그 패널로 시나리오 실행을 시각적으로 풍부하게 표현한다.

Purpose: F4.1(실시간 메시지 애니메이션)과 F4.2(로그 패널 상세)의 핵심 UI를 구현하여 사용자가 SIP 메시지 흐름을 시각적으로 추적 가능
Output: AnimatedMessageEdge 컴포넌트, 향상된 ExecutionLog 컴포넌트, Sonner toast 통합
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-execution-monitor/04-RESEARCH.md
@.planning/phases/04-execution-monitor/04-01-SUMMARY.md

Key existing files:
@frontend/src/features/scenario-builder/edges/branch-edge.tsx
@frontend/src/features/scenario-builder/components/canvas.tsx
@frontend/src/features/scenario-builder/components/execution-log.tsx
@frontend/src/features/scenario-builder/components/execution-toolbar.tsx
@frontend/src/features/scenario-builder/store/execution-store.ts
@frontend/src/features/scenario-builder/types/execution.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: AnimatedMessageEdge 컴포넌트 + Canvas/EdgeTypes 통합</name>
  <files>frontend/src/features/scenario-builder/edges/animated-message-edge.tsx, frontend/src/features/scenario-builder/edges/branch-edge.tsx, frontend/src/features/scenario-builder/components/canvas.tsx</files>
  <action>
  1. `edges/animated-message-edge.tsx` 신규 생성:
     - XYFlow의 공식 AnimatedSVGEdge 패턴 사용 (04-RESEARCH.md 참조)
     - `@xyflow/react`에서 `BaseEdge`, `getSmoothStepPath`, `EdgeProps` import
     - `useExecutionStore`에서 `edgeAnimations` 구독 (useShallow 사용)
     - 컴포넌트 구조:
       ```tsx
       export function AnimatedMessageEdge({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, data }: EdgeProps) {
         const edgeAnimations = useExecutionStore(
           useShallow((state) => state.edgeAnimations.filter(a => a.edgeId === id))
         );
         const removeEdgeAnimation = useExecutionStore((state) => state.removeEdgeAnimation);

         const [edgePath] = getSmoothStepPath({ sourceX, sourceY, sourcePosition, targetX, targetY, targetPosition });

         // 브랜치 색상 (branch-edge.tsx 패턴 그대로)
         const branchType = (data as any)?.branchType;
         const color = branchType === 'success' ? '#22c55e' : branchType === 'failure' ? '#ef4444' : '#94a3b8';

         // 애니메이션 완료 시 자동 제거 (useEffect)
         useEffect(() => {
           edgeAnimations.forEach((anim) => {
             const timer = setTimeout(() => removeEdgeAnimation(anim.id), anim.duration);
             return () => clearTimeout(timer);
           });
         }, [edgeAnimations, removeEdgeAnimation]);

         return (
           <>
             <BaseEdge id={id} path={edgePath} style={{ stroke: color, strokeWidth: 2 }} />
             {edgeAnimations.map((anim) => (
               <circle key={anim.id} r="5" fill="#3b82f6" opacity="0.9">
                 <animateMotion dur={`${anim.duration}ms`} path={edgePath} fill="remove" />
               </circle>
             ))}
           </>
         );
       }
       ```
     - **메모리 누수 방지**: `fill="remove"`로 애니메이션 완료 후 원위치, useEffect cleanup으로 타이머 정리
     - **성능**: useShallow로 해당 엣지의 애니메이션만 필터링하여 불필요한 리렌더링 방지

  2. `edges/branch-edge.tsx`에서 edgeTypes 수정:
     - AnimatedMessageEdge import 추가
     - `edgeTypes` 객체에 `animated: AnimatedMessageEdge` 추가
     - 기존 `branch: BranchEdge` 유지

  3. `components/canvas.tsx` 수정:
     - 실행 중(status === 'running') 엣지 애니메이션 트리거 로직 추가:
       - useExecutionStore에서 status, actionLogs 구독
       - useScenarioStore에서 edges 구독
       - actionLogs에 sipMessage가 포함된 새 로그가 추가될 때, 해당 nodeId에서 나가는 edge를 찾아 addEdgeAnimation 호출
       - useEffect로 actionLogs 길이 변화 감지 → 마지막 로그 확인 → sipMessage 있으면 엣지 애니메이션 생성
       - EdgeAnimationMessage 생성: `{ id: crypto.randomUUID(), edgeId: edge.id, method: sipMessage.method || '?', timestamp: Date.now(), duration: 1000 }`
     - 실행 중(`status === 'running'`)일 때 `defaultEdgeOptions.type`을 `'animated'`로 변경하여 모든 엣지가 AnimatedMessageEdge를 사용하도록 전환
       - 실행 중이 아닐 때는 기존 `'branch'` 유지
     - **중요**: defaultEdgeOptions는 useMemo로 status에 따라 변경:
       ```tsx
       const defaultEdgeOptions = useMemo(() => ({
         type: status === 'running' || status === 'completed' || status === 'failed' || status === 'stopped'
           ? 'animated' : 'branch'
       }), [status]);
       ```
       - 실행이 시작되면 기존 엣지들의 type도 'animated'로 변경해야 함 → 이를 위해 edges에 대한 별도 처리 대신, AnimatedMessageEdge가 BranchEdge의 모든 기능을 포함하도록 구현 (위의 브랜치 색상 로직 포함). 그러면 `defaultEdgeOptions = { type: 'animated' }`를 항상 사용해도 됨.
       - **결론**: edgeTypes에서 `branch` 키의 값을 `AnimatedMessageEdge`로 교체하여, 모든 branch 엣지가 자동으로 애니메이션 기능을 가지도록 한다. 별도의 type 전환 불필요.
       ```tsx
       // edges/branch-edge.tsx
       export const edgeTypes = {
         branch: AnimatedMessageEdge,  // BranchEdge를 AnimatedMessageEdge로 교체
       };
       ```
       - 기존 BranchEdge는 그대로 유지하되, export edgeTypes만 변경. AnimatedMessageEdge가 BranchEdge의 상위 호환이므로 안전.

  **주의사항:**
  - animateMotion의 dur 속성: CSS 시간 단위("1s") 또는 밀리초가 아닌 SVG 시간 형식 사용. `${anim.duration / 1000}s` 형태로 변환
  - XYFlow 12.x에서 z-index 변경 시 컴포넌트가 unmount되지 않으므로 useEffect cleanup 필수
  - `useShallow`를 import할 때: `import { useShallow } from 'zustand/react/shallow'`
  </action>
  <verify>
  - edges/ 디렉토리에 animated-message-edge.tsx 파일 존재
  - branch-edge.tsx의 edgeTypes에 AnimatedMessageEdge가 등록됨 (grep)
  - animated-message-edge.tsx에 `animateMotion`, `BaseEdge`, `getSmoothStepPath` 사용 확인 (grep)
  - animated-message-edge.tsx에 `useShallow` 사용 확인 (grep)
  - canvas.tsx에 edgeAnimation 트리거 로직 존재 (grep `addEdgeAnimation`)
  - `cd frontend && npx tsc --noEmit 2>&1 | head -30` TypeScript 에러 확인
  </verify>
  <done>AnimatedMessageEdge가 BranchEdge를 대체하여 모든 branch 엣지에서 SIP 메시지 애니메이션이 동작하고, Canvas가 sipMessage 포함 로그 발생 시 자동으로 엣지 애니메이션을 트리거한다.</done>
</task>

<task type="auto">
  <name>Task 2: 로그 패널 SIP 상세 정보 + Sonner toast 교체 + 로그 필터링</name>
  <files>frontend/src/features/scenario-builder/components/execution-log.tsx, frontend/src/features/scenario-builder/components/execution-toolbar.tsx</files>
  <action>
  1. `execution-log.tsx` 향상:
     - **SIP 메시지 상세 표시**: ActionLog에 sipMessage가 있으면 추가 정보 표시
       ```tsx
       {log.sipMessage && (
         <span className="text-purple-600">
           {log.sipMessage.direction === 'sent' ? ' ->' : ' <-'}
           {' '}{log.sipMessage.method}
           {log.sipMessage.responseCode ? ` ${log.sipMessage.responseCode}` : ''}
         </span>
       )}
       ```
     - **로그 레벨 필터링**: 헤더에 필터 토글 버튼 추가
       - useState로 `activeFilters: Set<string>` 관리 (기본값: 모든 레벨 활성)
       - info/warning/error 각각 토글 버튼 (작은 원형 배지)
       - 필터에 따라 actionLogs 필터링
     - **useShallow 적용**: actionLogs 구독에 useShallow 사용
       ```tsx
       import { useShallow } from 'zustand/react/shallow';
       const actionLogs = useExecutionStore(useShallow((state) => state.actionLogs));
       ```
     - **자동 스크롤 최적화**: isAtBottom 체크 추가
       - 사용자가 수동으로 위로 스크롤했으면 자동 스크롤 비활성화
       - 맨 아래에 있을 때만 새 로그 시 자동 스크롤
       ```tsx
       const [isAtBottom, setIsAtBottom] = useState(true);
       const containerRef = useRef<HTMLDivElement>(null);

       const handleScroll = () => {
         if (containerRef.current) {
           const { scrollTop, scrollHeight, clientHeight } = containerRef.current;
           setIsAtBottom(scrollHeight - scrollTop - clientHeight < 10);
         }
       };

       useEffect(() => {
         if (isAtBottom && endRef.current) {
           endRef.current.scrollIntoView({ behavior: 'smooth' });
         }
       }, [actionLogs, isAtBottom]);
       ```
     - **formatTimestamp 수정**: 현재 인자가 string인데 실제 데이터는 number(밀리초) → `(timestamp: number)` 로 타입 수정

  2. `execution-toolbar.tsx`에서 alert() → Sonner toast 교체:
     - `import { toast } from 'sonner';` 추가
     - `handleStart`의 `alert('No scenario selected...')` → `toast.warning('No scenario selected', { description: 'Please select or create a scenario first.' })`
     - `handleStart`의 catch에서 `alert('Failed to start...')` → `toast.error('Failed to start scenario', { description: String(error) })`
     - `handleStop`의 catch에서 `alert('Failed to stop...')` → `toast.error('Failed to stop scenario', { description: String(error) })`
     - Sonner는 이미 package.json에 설치됨 (sonner@2.0.7), Toaster는 이미 scenario-builder.tsx에 설정됨

  **주의사항:**
  - sonner의 `toast` 함수는 컴포넌트 외부에서도 호출 가능 (Toaster가 마운트되어 있으면)
  - useShallow는 배열에 대해 얕은 비교를 수행하여 참조만 바뀌고 내용이 같으면 리렌더링 방지
  - formatTimestamp의 타입을 number로 변경해도 `new Date(number)`는 정상 동작
  </action>
  <verify>
  - execution-log.tsx에 `sipMessage` 관련 렌더링 코드 존재 (grep `sipMessage.*method`)
  - execution-log.tsx에 필터링 로직 존재 (grep `activeFilters`)
  - execution-log.tsx에 `useShallow` import 존재 (grep)
  - execution-log.tsx에 `isAtBottom` 스크롤 최적화 존재 (grep)
  - execution-toolbar.tsx에 `toast` import 존재 (grep `from 'sonner'`)
  - execution-toolbar.tsx에 `alert(` 호출이 없음 (grep 결과 0건)
  - `cd frontend && npx tsc --noEmit 2>&1 | head -30` TypeScript 에러 확인
  </verify>
  <done>로그 패널에 SIP 메시지 direction/method/responseCode가 표시되고, 레벨별 필터링이 가능하며, alert()이 모두 Sonner toast로 교체되었다. 자동 스크롤이 사용자 스크롤 위치를 존중한다.</done>
</task>

</tasks>

<verification>
1. AnimatedMessageEdge: animateMotion SVG 애니메이션이 엣지 경로를 따라 원을 이동시킴
2. edgeTypes: branch 키가 AnimatedMessageEdge를 가리킴 (BranchEdge의 상위 호환)
3. Canvas: sipMessage 포함 로그 발생 시 edgeAnimation 자동 생성
4. ExecutionLog: SIP 상세 정보 (direction, method, responseCode) 표시
5. ExecutionLog: info/warning/error 필터 토글 동작
6. ExecutionToolbar: 모든 alert()이 toast로 교체됨
7. TypeScript 컴파일 에러 없음
</verification>

<success_criteria>
- 엣지를 따라 이동하는 원형 애니메이션이 SIP 메시지 발생 시 표시된다 (F4.1)
- 로그 패널에 SIP 메시지 상세 정보가 표시된다 (F4.2)
- 로그 레벨별 필터링이 동작한다
- alert() 대신 Sonner toast가 사용된다
- useShallow로 불필요한 리렌더링이 방지된다
</success_criteria>

<output>
완료 후, `.planning/phases/04-execution-monitor/04-02-SUMMARY.md` 생성
</output>
