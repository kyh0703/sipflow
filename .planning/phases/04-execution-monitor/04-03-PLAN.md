---
phase: 04-execution-monitor
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - frontend/src/features/scenario-builder/components/execution-timeline.tsx
  - frontend/src/features/scenario-builder/components/scenario-builder.tsx
autonomous: false

must_haves:
  truths:
    - "SIP 메시지 시퀀스가 시간축 기반 래더 다이어그램으로 표시된다"
    - "인스턴스별 수직 레인과 메시지 화살표가 올바른 방향으로 그려진다"
    - "로그 패널과 타임라인 패널 사이를 탭으로 전환할 수 있다"
    - "시각화 전체(엣지 애니메이션, 로그, 타임라인)가 통합되어 정상 동작한다"
  artifacts:
    - path: "frontend/src/features/scenario-builder/components/execution-timeline.tsx"
      provides: "SVG 기반 SIP 래더 다이어그램 컴포넌트"
      min_lines: 80
    - path: "frontend/src/features/scenario-builder/components/scenario-builder.tsx"
      provides: "Log/Timeline 탭 전환 레이아웃"
      contains: "ExecutionTimeline"
  key_links:
    - from: "frontend/src/features/scenario-builder/components/execution-timeline.tsx"
      to: "frontend/src/features/scenario-builder/store/execution-store.ts"
      via: "useExecutionStore에서 sipMessages 구독"
      pattern: "useExecutionStore.*sipMessages"
    - from: "frontend/src/features/scenario-builder/components/scenario-builder.tsx"
      to: "frontend/src/features/scenario-builder/components/execution-timeline.tsx"
      via: "ExecutionTimeline import 및 탭 조건부 렌더링"
      pattern: "import.*ExecutionTimeline"
---

<objective>
시간축 기반 SIP 래더 다이어그램과 탭 레이아웃으로 실행 모니터링 UI를 완성하고 시각적으로 검증한다.

Purpose: F4.3(타임라인 패널)을 구현하여 SIP 메시지 시퀀스를 시각적으로 파악할 수 있게 하고, 모든 Phase 04 기능의 통합을 완성
Output: ExecutionTimeline SVG 래더 컴포넌트, Log/Timeline 탭 전환 레이아웃, 통합 검증
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-execution-monitor/04-RESEARCH.md
@.planning/phases/04-execution-monitor/04-01-SUMMARY.md

Key existing files:
@frontend/src/features/scenario-builder/components/scenario-builder.tsx
@frontend/src/features/scenario-builder/components/execution-log.tsx
@frontend/src/features/scenario-builder/store/execution-store.ts
@frontend/src/features/scenario-builder/types/execution.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: ExecutionTimeline SVG 래더 다이어그램 컴포넌트 + 탭 레이아웃 통합</name>
  <files>frontend/src/features/scenario-builder/components/execution-timeline.tsx, frontend/src/features/scenario-builder/components/scenario-builder.tsx</files>
  <action>
  1. `execution-timeline.tsx` 신규 생성 (커스텀 SVG 래더 다이어그램):
     - 04-RESEARCH.md의 패턴 4 참조, 개선 적용
     - `useExecutionStore`에서 `sipMessages` 구독 (useShallow 사용)
     - `useExecutionStore`에서 `status` 구독

     **인스턴스 레인 계산:**
     ```tsx
     const lanes = useMemo(() => {
       const uniqueInstances = [...new Set(sipMessages.map((log) => log.instanceId))];
       return uniqueInstances;
     }, [sipMessages]);
     ```

     **SVG 레이아웃 상수:**
     - `LANE_WIDTH = 150` (인스턴스 간 간격)
     - `MESSAGE_HEIGHT = 40` (메시지 간 간격)
     - `HEADER_HEIGHT = 30` (인스턴스 이름 헤더)
     - `PADDING = 20` (좌우 여백)

     **SVG 구조:**
     ```tsx
     <div className="border-t border-border bg-background">
       <div className="flex items-center justify-between px-3 py-1 border-b border-border bg-muted/50">
         <span className="text-xs font-medium">Timeline</span>
         <span className="text-xs text-muted-foreground">{sipMessages.length} messages</span>
       </div>
       <div className="max-h-[200px] overflow-auto">
         {sipMessages.length === 0 ? (
           <div className="p-4 text-center text-xs text-muted-foreground">
             No SIP messages yet. Run a scenario to see the timeline.
           </div>
         ) : (
           <svg
             width={Math.max(lanes.length * LANE_WIDTH + PADDING * 2, 300)}
             height={sipMessages.length * MESSAGE_HEIGHT + HEADER_HEIGHT + PADDING}
           >
             {/* 화살표 마커 정의 */}
             <defs>
               <marker id="timeline-arrow" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                 <polygon points="0 0, 8 3, 0 6" fill="#3b82f6" />
               </marker>
               <marker id="timeline-arrow-red" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                 <polygon points="0 0, 8 3, 0 6" fill="#ef4444" />
               </marker>
             </defs>

             {/* 인스턴스 헤더 + 수직 라인 */}
             {lanes.map((lane, i) => {
               const x = PADDING + i * LANE_WIDTH + LANE_WIDTH / 2;
               return (
                 <g key={lane}>
                   <text x={x} y={16} textAnchor="middle" className="text-xs fill-foreground font-medium">{lane}</text>
                   <line x1={x} y1={HEADER_HEIGHT} x2={x} y2={sipMessages.length * MESSAGE_HEIGHT + HEADER_HEIGHT}
                     stroke="currentColor" strokeWidth={1} opacity={0.2} />
                 </g>
               );
             })}

             {/* 메시지 화살표 */}
             {sipMessages.map((msg, i) => {
               if (!msg.sipMessage) return null;
               const fromIndex = lanes.indexOf(msg.instanceId);
               // sent → 다음 인스턴스, received → 이전 인스턴스 (2개 인스턴스 기준)
               const toIndex = msg.sipMessage.direction === 'sent'
                 ? (fromIndex + 1) % lanes.length
                 : (fromIndex - 1 + lanes.length) % lanes.length;

               const y = HEADER_HEIGHT + i * MESSAGE_HEIGHT + MESSAGE_HEIGHT / 2;
               const x1 = PADDING + fromIndex * LANE_WIDTH + LANE_WIDTH / 2;
               const x2 = PADDING + toIndex * LANE_WIDTH + LANE_WIDTH / 2;
               const isError = msg.level === 'error';
               const label = msg.sipMessage.method
                 ? `${msg.sipMessage.method}${msg.sipMessage.responseCode ? ' ' + msg.sipMessage.responseCode : ''}`
                 : String(msg.sipMessage.responseCode || '');

               return (
                 <g key={msg.id}>
                   <line x1={x1} y1={y} x2={x2} y2={y}
                     stroke={isError ? '#ef4444' : '#3b82f6'} strokeWidth={1.5}
                     markerEnd={isError ? 'url(#timeline-arrow-red)' : 'url(#timeline-arrow)'} />
                   <text x={(x1 + x2) / 2} y={y - 5} textAnchor="middle"
                     className="text-[10px]" fill={isError ? '#ef4444' : '#3b82f6'}>
                     {label}
                   </text>
                   {/* 타임스탬프 (왼쪽) */}
                   <text x={5} y={y + 4} className="text-[9px] fill-muted-foreground">
                     {formatTime(msg.timestamp)}
                   </text>
                 </g>
               );
             })}
           </svg>
         )}
       </div>
     </div>
     ```

     **formatTime 유틸리티:**
     ```tsx
     function formatTime(timestamp: number): string {
       const d = new Date(timestamp);
       return `${d.getMinutes().toString().padStart(2,'0')}:${d.getSeconds().toString().padStart(2,'0')}.${d.getMilliseconds().toString().padStart(3,'0')}`;
     }
     ```

     **idle 상태 처리:** status === 'idle'이면 null 반환 (ExecutionLog과 동일 패턴)

     **자동 스크롤:** 새 메시지 추가 시 스크롤 컨테이너를 맨 아래로 이동 (isAtBottom 패턴)

  2. `scenario-builder.tsx`에서 Log/Timeline 탭 레이아웃 추가:
     - ExecutionTimeline import
     - 실행 상태가 idle가 아닐 때, 하단 영역에 탭 UI 추가:
       ```tsx
       import { useState } from 'react';  // 기존 import에 추가
       import { ExecutionTimeline } from './execution-timeline';

       // ScenarioBuilder 컴포넌트 내부
       const [bottomTab, setBottomTab] = useState<'log' | 'timeline'>('log');
       const executionStatus = useExecutionStore((state) => state.status);
       ```
     - Center 영역의 `<ExecutionLog />` 를 탭 시스템으로 교체:
       ```tsx
       {/* Center: Canvas + Bottom Panel */}
       <div className="flex-1 flex flex-col">
         <div className="flex-1">
           <Canvas />
         </div>
         {executionStatus !== 'idle' && (
           <div className="border-t border-border">
             {/* 탭 헤더 */}
             <div className="flex border-b border-border bg-muted/50">
               <button
                 className={`px-3 py-1 text-xs font-medium ${bottomTab === 'log' ? 'bg-background border-b-2 border-primary' : 'text-muted-foreground'}`}
                 onClick={() => setBottomTab('log')}
               >
                 Log
               </button>
               <button
                 className={`px-3 py-1 text-xs font-medium ${bottomTab === 'timeline' ? 'bg-background border-b-2 border-primary' : 'text-muted-foreground'}`}
                 onClick={() => setBottomTab('timeline')}
               >
                 Timeline
               </button>
             </div>
             {/* 탭 콘텐츠 */}
             {bottomTab === 'log' ? <ExecutionLog /> : <ExecutionTimeline />}
           </div>
         )}
       </div>
       ```
     - **ExecutionLog 수정 필요**: ExecutionLog 내부의 status === 'idle' 체크와 border-t를 제거해야 함 (상위에서 조건부 렌더링하므로). 단, ExecutionLog는 Plan 02에서 수정하므로, scenario-builder.tsx에서 조건부 렌더링을 상위로 이동하면 ExecutionLog의 idle 체크는 중복이지만 해롭지 않음 (상위에서 이미 필터링됨). 그대로 두어도 안전.
     - ExecutionTimeline도 동일하게 status === 'idle'이면 null 반환하되, 상위 조건과 중복은 방어적 코딩.

  **주의사항:**
  - SVG viewBox는 사용하지 않고 width/height를 직접 설정 (스크롤 컨테이너와 호환)
  - 인스턴스가 1개일 때 (래더 다이어그램 의미 없음): self-loop 화살표 대신 단순 텍스트 목록으로 fallback
  - lanes.length가 0이면 빈 상태 메시지 표시
  - SVG text의 fill 색상은 Tailwind CSS 변수를 직접 사용 불가 → className으로 처리하거나 currentColor 활용
  - `scenario-builder.tsx`에서 useExecutionStore import 추가 필요
  </action>
  <verify>
  - execution-timeline.tsx 파일 존재, 최소 80줄
  - execution-timeline.tsx에 `<svg`, `<line`, `markerEnd`, `<animateMotion` 또는 `<marker` 존재 (grep)
  - execution-timeline.tsx에 `useShallow` import 존재 (grep)
  - execution-timeline.tsx에 `sipMessages` 구독 존재 (grep)
  - scenario-builder.tsx에 `ExecutionTimeline` import 존재 (grep)
  - scenario-builder.tsx에 탭 전환 로직 존재 (grep `bottomTab`)
  - scenario-builder.tsx에 `useExecutionStore` import 존재 (grep)
  - `cd frontend && npx tsc --noEmit 2>&1 | head -30` TypeScript 에러 확인
  </verify>
  <done>ExecutionTimeline이 SIP 메시지를 래더 다이어그램으로 시각화하고, 하단 패널에서 Log/Timeline 탭 전환이 동작한다. 인스턴스별 레인, 방향 화살표, 메서드/응답코드 라벨, 타임스탬프가 표시된다.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Phase 04 전체 실행 모니터 기능:
  1. 엣지 메시지 애니메이션 (SIP 메시지 발생 시 엣지를 따라 이동하는 원형)
  2. 향상된 로그 패널 (SIP 방향/메서드/응답코드, 레벨 필터, Sonner toast)
  3. 타임라인 패널 (SVG 래더 다이어그램, 인스턴스별 레인, 메시지 화살표)
  4. Log/Timeline 탭 전환 레이아웃
  </what-built>
  <how-to-verify>
  1. `cd /home/overthinker/Project/sipflow && wails dev` 실행
  2. 기존 시나리오를 열거나, 새 시나리오 생성 (MakeCall → Answer → Release 등)
  3. [Run] 버튼 클릭하여 시나리오 실행
  4. 확인 항목:
     a. **엣지 애니메이션**: 노드 간 엣지를 따라 파란색 원이 이동하는가?
     b. **로그 패널**: 하단 "Log" 탭에서 SIP 메시지 상세 정보 (→/← 방향, INVITE/BYE 등) 표시되는가?
     c. **로그 필터**: info/warning/error 필터 토글이 동작하는가?
     d. **타임라인**: "Timeline" 탭 클릭 시 래더 다이어그램이 표시되는가?
     e. **타임라인 내용**: 인스턴스별 수직 레인, 메시지 화살표, 메서드 라벨이 올바른가?
     f. **탭 전환**: Log ↔ Timeline 탭 전환이 자연스러운가?
     g. **Toast**: 에러 발생 시 우측 하단에 toast 알림이 표시되는가? (alert가 아닌)
     h. **idle 상태**: 시나리오 실행 전에는 하단 패널이 숨겨져 있는가?
  5. [Stop] 버튼으로 시나리오 중단 후에도 로그/타임라인 데이터가 유지되는가?
  </how-to-verify>
  <resume-signal>"approved"를 입력하거나 발견된 문제를 설명하세요</resume-signal>
</task>

</tasks>

<verification>
1. ExecutionTimeline: SVG 래더 다이어그램이 sipMessages 데이터를 기반으로 렌더링
2. 인스턴스 레인: 고유 인스턴스별 수직 라인과 헤더 표시
3. 메시지 화살표: direction에 따라 올바른 방향, method/responseCode 라벨
4. 탭 전환: Log/Timeline 탭이 scenario-builder.tsx에서 동작
5. 빈 상태: sipMessages가 없을 때 안내 메시지 표시
6. 인간 검증: 시나리오 실행 시 전체 시각화 기능 동작 확인
</verification>

<success_criteria>
- F4.3: 시간축 기반 SIP 메시지 시퀀스가 래더 다이어그램으로 표시된다
- Log/Timeline 탭 전환이 자연스럽게 동작한다
- 시나리오 실행 시 모든 시각화(엣지 애니메이션 + 로그 + 타임라인)가 통합적으로 동작한다
- 인간 검증자가 시각적 동작을 승인한다
</success_criteria>

<output>
완료 후, `.planning/phases/04-execution-monitor/04-03-SUMMARY.md` 생성
</output>
