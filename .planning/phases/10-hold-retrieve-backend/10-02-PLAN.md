---
phase: 10-hold-retrieve-backend
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - internal/engine/executor.go
  - internal/engine/executor_test.go
autonomous: true

must_haves:
  truths:
    - "Hold Command 노드 실행 시 MediaSession.Mode가 sendonly로 설정되고 ReInvite()가 호출된다"
    - "Retrieve Command 노드 실행 시 MediaSession.Mode가 sendrecv로 복원되고 ReInvite()가 호출된다"
    - "HeldEvent 노드가 SessionStore SIP 이벤트 버스에서 HELD 이벤트를 블로킹 대기한다"
    - "RetrievedEvent 노드가 SessionStore SIP 이벤트 버스에서 RETRIEVED 이벤트를 블로킹 대기한다"
    - "executeCommand switch에 Hold, Retrieve가 등록되고 executeEvent switch에 HELD, RETRIEVED가 등록된다"
  artifacts:
    - path: "internal/engine/executor.go"
      provides: "executeHold, executeRetrieve, executeWaitSIPEvent 함수, switch 확장"
      contains: "executeHold"
    - path: "internal/engine/executor_test.go"
      provides: "Hold/Retrieve/HeldEvent/RetrievedEvent 에러 경로 테스트 + SIP 이벤트 통합 테스트"
      contains: "TestExecuteHold"
  key_links:
    - from: "internal/engine/executor.go executeHold"
      to: "diago MediaSession.Mode"
      via: "dialog.Media().MediaSession().Mode = sdp.ModeSendonly"
      pattern: "ModeSendonly"
    - from: "internal/engine/executor.go executeRetrieve"
      to: "diago MediaSession.Mode"
      via: "dialog.Media().MediaSession().Mode = sdp.ModeSendrecv"
      pattern: "ModeSendrecv"
    - from: "internal/engine/executor.go executeWaitSIPEvent"
      to: "internal/engine/executor.go SessionStore"
      via: "ex.sessions.SubscribeSIPEvent(instanceID, eventType)"
      pattern: "SubscribeSIPEvent"
    - from: "internal/engine/executor.go executeCommand"
      to: "internal/engine/executor.go executeHold"
      via: "case Hold switch"
      pattern: "case \"Hold\""
    - from: "internal/engine/executor.go executeEvent"
      to: "internal/engine/executor.go executeWaitSIPEvent"
      via: "case HELD/RETRIEVED switch"
      pattern: "case \"HELD\""
---

<objective>
Hold Command, Retrieve Command, HeldEvent, RetrievedEvent 핸들러를 구현하고 테스트한다. HOLD-01 ~ HOLD-04 요구사항 전체를 충족한다.

Purpose: 사용자가 시나리오에서 Hold/Retrieve 노드를 배치하면 SIP Re-INVITE가 올바른 SDP 방향으로 전송되고, 상대방의 Hold/Retrieve를 이벤트 노드로 감지할 수 있다.
Output: 4개의 새 핸들러 함수 (executeHold, executeRetrieve, executeWaitSIPEvent), executeCommand/executeEvent switch 확장, 에러 경로 + 이벤트 버스 통합 테스트
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-hold-retrieve-backend/10-RESEARCH.md
@.planning/phases/10-hold-retrieve-backend/10-01-SUMMARY.md
@internal/engine/executor.go
@internal/engine/executor_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: executeHold, executeRetrieve, executeWaitSIPEvent 구현 + switch 확장</name>
  <files>
    internal/engine/executor.go
  </files>
  <action>
**import 추가:**
`"github.com/emiago/diago/media/sdp"` — sdp.ModeSendonly, sdp.ModeSendrecv 상수 사용.

**executeHold() 함수 추가:**
10-RESEARCH.md 패턴 1 (예시 1: 완전한 executeHold 구현)을 따른다.

```go
func (ex *Executor) executeHold(ctx context.Context, instanceID string, node *GraphNode) error
```

구현 상세:
1. 액션 로그: `"Hold: sending Re-INVITE (sendonly)"`
2. `ex.sessions.GetDialog(instanceID)` — 없으면 에러: `"Hold: no active dialog for instance %s"`
3. `dialog.Media().MediaSession()` → nil이면 에러: `"Hold: no media session available"`
4. `mediaSess.Mode = sdp.ModeSendonly`
5. 타입 어서션 `type reInviter interface { ReInvite(ctx context.Context) error }` — dialog가 지원 안 하면 에러: `"Hold: dialog type %T does not support ReInvite"`
6. `ri.ReInvite(ctx)` 호출 — 실패 시 `mediaSess.Mode = sdp.ModeSendrecv` 복원 후 에러 반환
7. 성공 로그: `WithSIPMessage("sent", "INVITE", 200, "", "", "", "sendonly")`

**executeRetrieve() 함수 추가:**
10-RESEARCH.md 패턴 2를 따른다. executeHold()와 동일 구조, Mode만 다름.

```go
func (ex *Executor) executeRetrieve(ctx context.Context, instanceID string, node *GraphNode) error
```

구현 상세:
1. 액션 로그: `"Retrieve: sending Re-INVITE (sendrecv)"`
2. `ex.sessions.GetDialog(instanceID)` — 없으면 에러: `"Retrieve: no active dialog for instance %s"`
3. `dialog.Media().MediaSession()` → nil이면 에러: `"Retrieve: no media session available"`
4. `mediaSess.Mode = sdp.ModeSendrecv`
5. 동일한 reInviter 타입 어서션 — 실패 에러: `"Retrieve: dialog type %T does not support ReInvite"`
6. `ri.ReInvite(ctx)` 호출 — 실패 시 에러 반환 (Mode 복원은 sendrecv가 기본이므로 불필요)
7. 성공 로그: `WithSIPMessage("sent", "INVITE", 200, "", "", "", "sendrecv")`

**executeWaitSIPEvent() 함수 추가:**
10-RESEARCH.md 패턴 6을 따른다. HELD/RETRIEVED 공통 이벤트 대기.

```go
func (ex *Executor) executeWaitSIPEvent(ctx context.Context, instanceID string, node *GraphNode, eventType string, timeout time.Duration) error
```

구현 상세:
1. `ex.sessions.SubscribeSIPEvent(instanceID, eventType)` → 채널 획득
2. `defer ex.sessions.UnsubscribeSIPEvent(instanceID, eventType, ch)` — 정리
3. select:
   - `case <-ch:` → 성공 로그 `fmt.Sprintf("%s event received", eventType)` + return nil
   - `case <-ctx.Done():` → 에러 `fmt.Sprintf("%s event timeout after %v", eventType, timeout)`

**executeCommand() switch 확장:**
기존 switch에 두 case 추가:
```go
case "Hold":
    return ex.executeHold(ctx, instanceID, node)
case "Retrieve":
    return ex.executeRetrieve(ctx, instanceID, node)
```
`"SendDTMF"` case 뒤, `default` 앞에 배치.

**executeEvent() switch 확장:**
기존 switch에 두 case 추가:
```go
case "HELD":
    return ex.executeWaitSIPEvent(timeoutCtx, instanceID, node, "HELD", timeout)
case "RETRIEVED":
    return ex.executeWaitSIPEvent(timeoutCtx, instanceID, node, "RETRIEVED", timeout)
```
`"DTMFReceived"` case 뒤, `default` 앞에 배치.

**주의사항:**
- `sdp` import: `"github.com/emiago/diago/media/sdp"` 정확한 경로 확인. go mod에 이미 diago가 있으므로 하위 패키지 자동 해결.
- reInviter 인터페이스는 각 함수 내부에 로컬로 정의 (exported 불필요).
  </action>
  <verify>
`cd /home/overthinker/Project/sipflow && go build ./...` — 컴파일 성공 (sdp import 포함).
`go vet ./internal/engine/...` — 경고 없음.
grep 확인:
- `grep -n "case \"Hold\"" internal/engine/executor.go` — switch에 등록됨
- `grep -n "case \"Retrieve\"" internal/engine/executor.go` — switch에 등록됨
- `grep -n "case \"HELD\"" internal/engine/executor.go` — switch에 등록됨
- `grep -n "case \"RETRIEVED\"" internal/engine/executor.go` — switch에 등록됨
- `grep -n "ModeSendonly" internal/engine/executor.go` — sdp 상수 사용됨
  </verify>
  <done>
executeHold()가 Mode=sendonly + ReInvite()를 호출한다. executeRetrieve()가 Mode=sendrecv + ReInvite()를 호출한다. executeWaitSIPEvent()가 SubscribeSIPEvent 채널에서 블로킹 대기한다. executeCommand switch에 Hold/Retrieve, executeEvent switch에 HELD/RETRIEVED가 등록된다. `go build ./...`가 성공한다.
  </done>
</task>

<task type="auto">
  <name>Task 2: Hold/Retrieve + HeldEvent/RetrievedEvent 에러 경로 테스트</name>
  <files>
    internal/engine/executor_test.go
  </files>
  <action>
기존 `newTestExecutor()` 헬퍼를 사용하여 에러 경로 테스트 추가. 기존 `TestExecutePlayAudio_NoDialog`, `TestExecuteSendDTMF_NoDialog` 패턴을 따른다.

**새 테스트 함수들:**

1. `TestExecuteHold_NoDialog`:
   - `newTestExecutor(t)` 생성
   - `node := &GraphNode{ID: "test-node", Type: "command", Command: "Hold"}`
   - `ex.executeHold(context.Background(), "inst-1", node)` 호출
   - 에러 포함 확인: `"no active dialog"`

2. `TestExecuteRetrieve_NoDialog`:
   - 동일 패턴, `Command: "Retrieve"`
   - `ex.executeRetrieve(context.Background(), "inst-1", node)` 호출
   - 에러 포함 확인: `"no active dialog"`

3. `TestExecuteCommand_HoldSwitch`:
   - `newTestExecutor(t)` 생성
   - `node := &GraphNode{ID: "test-node", Type: "command", Command: "Hold", InstanceID: "inst-1"}`
   - `ex.executeCommand(context.Background(), "inst-1", node)` 호출
   - 에러 발생 확인 (dialog 없으므로 에러는 맞지만, switch가 올바르게 라우팅되는지 확인)
   - 에러 메시지에 "no active dialog" 포함 (Hold 핸들러까지 도달 확인)

4. `TestExecuteCommand_RetrieveSwitch`:
   - 동일 패턴, `Command: "Retrieve"`
   - 에러 메시지에 "no active dialog" 포함

5. `TestExecuteEvent_HeldSwitch`:
   - `newTestExecutor(t)` 생성
   - `node := &GraphNode{ID: "test-node", Type: "event", Event: "HELD", InstanceID: "inst-1", Timeout: 100 * time.Millisecond}`
   - 100ms 타임아웃 컨텍스트로 `ex.executeEvent(context.Background(), "inst-1", node)` 호출
   - 에러 확인: `"HELD event timeout"` (구독 후 이벤트 없으므로 타임아웃)

6. `TestExecuteEvent_RetrievedSwitch`:
   - 동일 패턴, `Event: "RETRIEVED"`
   - 에러 확인: `"RETRIEVED event timeout"`

7. `TestExecuteWaitSIPEvent_Success`:
   - `newTestExecutor(t)` 생성
   - goroutine으로 50ms 후 `ex.sessions.emitSIPEvent("inst-1", "HELD")` 호출
   - `node := &GraphNode{ID: "test-node", Type: "event", Event: "HELD", Timeout: 2 * time.Second}`
   - 2초 타임아웃 컨텍스트로 `ex.executeWaitSIPEvent(ctx, "inst-1", node, "HELD", 2*time.Second)` 호출
   - 에러 없음 확인 (nil)

8. `TestExecuteWaitSIPEvent_Timeout`:
   - `newTestExecutor(t)` 생성
   - 이벤트 발행 없이 100ms 타임아웃으로 `executeWaitSIPEvent` 호출
   - 에러 확인: `"timeout"`
  </action>
  <verify>
`cd /home/overthinker/Project/sipflow && go test ./internal/engine/ -v` — 모든 테스트 통과 (기존 + Plan 01 신규 + Plan 02 신규).
신규 테스트만: `go test ./internal/engine/ -run "TestExecuteHold|TestExecuteRetrieve|TestExecuteCommand_Hold|TestExecuteCommand_Retrieve|TestExecuteEvent_Held|TestExecuteEvent_Retrieved|TestExecuteWaitSIPEvent" -v` — 통과.
  </verify>
  <done>
Hold/Retrieve Command의 에러 경로(dialog 없음)가 테스트된다. HELD/RETRIEVED Event의 타임아웃 경로가 테스트된다. executeCommand/executeEvent switch 라우팅이 검증된다. executeWaitSIPEvent의 성공 경로(이벤트 수신)와 타임아웃 경로가 모두 테스트된다. 전체 `go test ./internal/engine/`가 통과한다.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` — 전체 프로젝트 컴파일 성공
2. `go test ./internal/engine/ -v` — 모든 테스트 통과 (기존 12개 + Plan 01 신규 + Plan 02 신규)
3. `go vet ./internal/engine/...` — 경고 없음
4. 요구사항 매핑 확인:
   - HOLD-01: `grep -n "executeHold" internal/engine/executor.go` + `grep -n "case \"Hold\""`
   - HOLD-02: `grep -n "executeRetrieve" internal/engine/executor.go` + `grep -n "case \"Retrieve\""`
   - HOLD-03: `grep -n "case \"HELD\"" internal/engine/executor.go`
   - HOLD-04: `grep -n "case \"RETRIEVED\"" internal/engine/executor.go`
   - AnswerOptions: `grep -n "AnswerOptions" internal/engine/executor.go`
</verification>

<success_criteria>
- HOLD-01: Hold Command가 executeCommand switch에 등록되고 executeHold()가 Mode=sendonly + ReInvite()를 실행한다
- HOLD-02: Retrieve Command가 executeCommand switch에 등록되고 executeRetrieve()가 Mode=sendrecv + ReInvite()를 실행한다
- HOLD-03: HeldEvent가 executeEvent switch에 등록되고 executeWaitSIPEvent("HELD")로 이벤트 버스에서 블로킹 대기한다
- HOLD-04: RetrievedEvent가 executeEvent switch에 등록되고 executeWaitSIPEvent("RETRIEVED")로 이벤트 버스에서 블로킹 대기한다
- 에러 경로(dialog 없음, 타임아웃)와 성공 경로(이벤트 수신)가 모두 테스트된다
- go build와 go test가 모두 통과한다
</success_criteria>

<output>
완료 후, `.planning/phases/10-hold-retrieve-backend/10-02-SUMMARY.md` 생성
</output>
